2023-04-29 18:03:23 - SOTA_Logger - [32m[40mINFO[0m - Summarizing langchain/langchain/tools/
Using 30 context chunks
Prompt: What does this code do?[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 938[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 2181[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 8818[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Splitting tokens: 8818 into chunks of 1000 tokens and 818 remainder[0m
2023-04-29 18:03:23 - index_codebase - [36m[40mDEBUG[0m - Splitting code into 9 chunks[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 2210[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 29[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 864[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 0[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 3517[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 19[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 1182[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 6166[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Splitting tokens: 6166 into chunks of 1000 tokens and 166 remainder[0m
2023-04-29 18:03:23 - index_codebase - [36m[40mDEBUG[0m - Splitting code into 7 chunks[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 33[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 896[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 0[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 1559[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 49[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 550[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 4239[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 1369[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 0[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 908[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 1181[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 0[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 0[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 20547[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Splitting tokens: 20547 into chunks of 1000 tokens and 547 remainder[0m
2023-04-29 18:03:23 - index_codebase - [36m[40mDEBUG[0m - Splitting code into 21 chunks[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 9653[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Splitting tokens: 9653 into chunks of 1000 tokens and 653 remainder[0m
2023-04-29 18:03:23 - index_codebase - [36m[40mDEBUG[0m - Splitting code into 10 chunks[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 52[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 5280[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Splitting tokens: 5280 into chunks of 1000 tokens and 280 remainder[0m
2023-04-29 18:03:23 - index_codebase - [36m[40mDEBUG[0m - Splitting code into 6 chunks[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 33[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 1558[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 33[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 891[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 46[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 3604[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 19[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 2335[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 1509[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 137[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 2096[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 31[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 1532[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 52[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 6259[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Splitting tokens: 6259 into chunks of 1000 tokens and 259 remainder[0m
2023-04-29 18:03:23 - index_codebase - [36m[40mDEBUG[0m - Splitting code into 7 chunks[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 7434[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Splitting tokens: 7434 into chunks of 1000 tokens and 434 remainder[0m
2023-04-29 18:03:23 - index_codebase - [36m[40mDEBUG[0m - Splitting code into 8 chunks[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 25[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 947[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 39[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 984[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 34[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 980[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 43[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 681[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 51[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - Tokenizing code: 3082[0m
2023-04-29 18:03:23 - index_codebase - [32m[40mINFO[0m - New DF has 115 rows with 106675 tokens[0m
2023-04-29 18:03:40 - Indexing codebase - [32m[40mINFO[0m - Indexed 68 rows[0m
2023-04-29 18:03:40 - SOTA_Logger - [32m[40mINFO[0m - Generating summary...[0m
2023-04-29 18:03:40 - SOTA_Logger - [32m[40mINFO[0m - Writing summary...[0m
2023-04-29 18:03:40 - Summary Logger - [32m[40mINFO[0m - Token length is 591 for /Users/clockcoin/parsero/langchain/langchain/tools/base.py_chunk_0 chunk[0m
2023-04-29 18:03:49 - Summary Logger - [32m[40mINFO[0m - Token length is 578 for /Users/clockcoin/parsero/langchain/langchain/tools/base.py_chunk_1 chunk[0m
2023-04-29 18:03:54 - Summary Logger - [32m[40mINFO[0m - Token length is 623 for /Users/clockcoin/parsero/langchain/langchain/tools/base.py_chunk_2 chunk[0m
2023-04-29 18:03:57 - Summary Logger - [32m[40mINFO[0m - Token length is 611 for /Users/clockcoin/parsero/langchain/langchain/tools/base.py_chunk_3 chunk[0m
2023-04-29 18:04:03 - Summary Logger - [32m[40mINFO[0m - Token length is 580 for /Users/clockcoin/parsero/langchain/langchain/tools/base.py_chunk_4 chunk[0m
2023-04-29 18:04:08 - Summary Logger - [32m[40mINFO[0m - Token length is 619 for /Users/clockcoin/parsero/langchain/langchain/tools/base.py_chunk_5 chunk[0m
2023-04-29 18:11:26 - PARSERO - [32m[40mINFO[0m - Getting embeddings[0m
2023-04-29 18:11:26 - PARSERO - [32m[40mINFO[0m - Calculating summary similarities[0m
2023-04-29 18:11:26 - PARSERO - [32m[40mINFO[0m - Calculating code similarities[0m
2023-04-29 18:11:26 - PARSERO - [32m[40mINFO[0m - File:agent.py_chunk_620-640
Code:
            return output
        actions: List[AgentAction]
        if isinstance(output, AgentAction):
            actions = [output]
        else:
            actions = output
        async def _aperform_agent_action(
            agent_action: AgentAction,
        ) -> Tuple[AgentAction, str]:
            if self.callback_manager.is_async:
                await self.callback_manager.on_agent_action(
                    agent_action, verbose=self.verbose, color="green"
                )
            else:
                self.callback_manager.on_agent_action(
                    agent_action, verbose=self.verbose, color="green"
                )
            if agent_action.tool in name_to_tool_map:
                tool = name_to_tool_map[agent_action.tool]
                return_direct = tool.return_direct
Summary:
Contains code for an Agent class, which is used to interact with the environment
 - Includes methods for performing agent actions and handling callbacks
 - Defines a mapping between tool names and their corresponding classes  ```
[0m
2023-04-29 18:11:26 - PARSERO - [32m[40mINFO[0m - File:wiki_prompt.py_chunk_20-40
Code:
Observation: Milhouse Mussolini Van Houten is a recurring character in the Fox animated television series The Simpsons voiced by Pamela Hayden and created by Matt Groening.
Thought: The paragraph does not tell who Milhouse is named after, maybe I can look up "named after".
Action: Lookup[named after]
Observation: (Result 1 / 1) Milhouse was named after U.S. president Richard Nixon, whose middle name was Milhous.
Thought: Milhouse was named after U.S. president Richard Nixon, so the answer is Richard Nixon.
Action: Finish[Richard Nixon]""",
    """Question: Which documentary is about Finnish rock groups, Adam Clayton Powell or The Saimaa Gesture?
Thought: I need to search Adam Clayton Powell and The Saimaa Gesture, and find which documentary is about Finnish rock groups.
Action: Search[Adam Clayton Powell]
Observation: Could not find [Adam Clayton Powell]. Similar: [â€™Adam Clayton Powell IIIâ€™, â€™Seventh Avenue (Manhattan)â€™, â€™Adam Clayton Powell Jr. State Office Buildingâ€™, â€™Isabel Washington Powellâ€™, â€™Adam Powellâ€™, â€™Adam Clayton Powell (film)â€™, â€™Giancarlo Espositoâ€™].
Thought: To find the documentary, I can search Adam Clayton Powell (film).
Action: Search[Adam Clayton Powell (film)]
Observation: Adam Clayton Powell is a 1989 American documentary film directed by Richard Kilberg. The film is about the rise and fall of influential African-American politician Adam Clayton Powell Jr.[3][4] It was later aired as part of the PBS series The American Experience.
Thought: Adam Clayton Powell (film) is a documentary about an African-American politician, not Finnish rock groups. So the documentary about Finnish rock groups must instead be The Saimaa Gesture.
Action: Finish[The Saimaa Gesture]""",
    """Question: What profession does Nicholas Ray and Elia Kazan have in common?
Thought: I need to search Nicholas Ray and Elia Kazan, find their professions, then find the profession they have in common.
Action: Search[Nicholas Ray]
Observation: Nicholas Ray (born Raymond Nicholas Kienzle Jr., August 7, 1911 - June 16, 1979) was an American film director, screenwriter, and actor best known for the 1955 film Rebel Without a Cause.
Thought: Professions of Nicholas Ray are director, screenwriter, and actor. I need to search Elia Kazan next and find his professions.
Summary:
A Python file that contains a React-based Wiki Prompt agent
 - The agent is used to generate natural language responses from user input
 - It uses the spaCy library for natural language processing and text analysis 
 - It also uses the GPT-2 model for generating responses 
 - The codebase includes functions for tokenizing, lemmatizing, and tagging words in user input ```
[0m
2023-04-29 18:11:26 - PARSERO - [32m[40mINFO[0m - File:planner_prompt.py_chunk_60-80
Code:
Begin!
Plan: {input}
Thought:
{agent_scratchpad}
"""
API_CONTROLLER_TOOL_NAME = "api_controller"
API_CONTROLLER_TOOL_DESCRIPTION = f"Can be used to execute a plan of API calls, like {API_CONTROLLER_TOOL_NAME}(plan)."
API_ORCHESTRATOR_PROMPT = """You are an agent that assists with user queries against API, things like querying information or creating resources.
Some user queries can be resolved in a single API call, particularly if you can find appropriate params from the OpenAPI spec; though some require several API call.
You should always plan your API calls first, and then execute the plan second.
If the plan includes a DELETE call, be sure to ask the User for authorization first unless the User has specifically asked to delete something.
You should never return information without executing the api_controller tool.
Here are the tools to plan and execute API requests: {tool_descriptions}
Starting below, you should follow this format:
User query: the query a User wants help with related to the API
Thought: you should always think about what to do
Action: the action to take, should be one of the tools [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Summary:
A Python file that contains a prompt for the user to plan their API calls
 - Includes tools to help with planning and executing API requests
 - Contains descriptions of each tool, as well as instructions on how to use them 
```
[0m
2023-04-29 18:11:26 - PARSERO - [32m[40mINFO[0m - File:textworld_prompt.py_chunk_20-40
Code:
be empty. If you haven't noticed it already, there seems to be something there
by the wall, it's a table. Unfortunately, there isn't a thing on it. Hm. Oh well
There is an exit to the west. Don't worry, it is unguarded.
Thought: I need to take the binder from the locker
Action: Play[take binder]
Observation: You take the binder from the locker.
Thought: I need to place the binder on the mantelpiece
Action: Play[put binder on mantelpiece]
Observation: You put the binder on the mantelpiece.
Your score has just gone up by one point.
*** The End ***
Thought: The End has occurred
Action: Finish[yes]
"""
]
SUFFIX = """\n\nSetup: {input}
{agent_scratchpad}"""
TEXTWORLD_PROMPT = PromptTemplate.from_examples(
    EXAMPLES, SUFFIX, ["input", "agent_scratchpad"]
)
Summary:
It is a Python file located in the langchain/agents/react directory.
 - The file contains code for creating PromptTemplate objects from examples, suffixes and input parameters. 
 - It also includes functions to generate text-based prompts based on user inputs. ```
[0m
2023-04-29 18:11:26 - PARSERO - [32m[40mINFO[0m - File:prompt.py_chunk_0-20
Code:
PREFIX = """Assistant is a large language model trained by OpenAI.
Assistant is designed to be able to assist with a wide range of tasks, from answering simple questions to providing in-depth explanations and discussions on a wide range of topics. As a language model, Assistant is able to generate human-like text based on the input it receives, allowing it to engage in natural-sounding conversations and provide responses that are coherent and relevant to the topic at hand.
Assistant is constantly learning and improving, and its capabilities are constantly evolving. It is able to process and understand large amounts of text, and can use this knowledge to provide accurate and informative responses to a wide range of questions. Additionally, Assistant is able to generate its own text based on the input it receives, allowing it to engage in discussions and provide explanations and descriptions on a wide range of topics.
Overall, Assistant is a powerful tool that can help with a wide range of tasks and provide valuable insights and information on a wide range of topics. Whether you need help with a specific question or just want to have a conversation about a particular topic, Assistant is here to assist.
TOOLS:
------
Assistant has access to the following tools:"""
FORMAT_INSTRUCTIONS = """To use a tool, please use the following format:
```
Thought: Do I need to use a tool? Yes
Action: the action to take, should be one of [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
```
When you have a response to say to the Human, or if you do not need to use a tool, you MUST use the format:
```
Thought: Do I need to use a tool? No
{ai_prefix}: [your response here]
```"""
SUFFIX = """Begin!
Summary:
Prompt.py is a file within the project directory that contains code for creating and managing conversations with users. 
 - It includes functions to create prompts, parse user input, and respond accordingly. 
 - The file also contains methods for handling errors in user input as well as providing helpful hints when needed. 
 - Additionally, it provides support for natural language processing (NLP) tasks such as sentiment analysis and entity extraction. ```
[0m
2023-04-29 18:11:26 - PARSERO - [32m[40mINFO[0m - File:prompt.py
Code:
# flake8: noqa

PREFIX = """You are an agent designed to write and execute python code to answer questions.
You have access to a python REPL, which you can use to execute python code.
If you get an error, debug your code and try again.
Only use the output of your code to answer the question. 
You might know the answer without running any code, but you should still run the code to get the answer.
If it does not seem like you can write code to answer the question, just return "I don't know" as the answer.
"""

Summary:
Contains a SQL_PREFIX and SQL_SUFFIX string which provide instructions for the agent to interact with a SQL database.
 - The prefix provides instructions on how to create syntactically correct queries, limit results, order results by relevant columns, and not query all columns from a specific table. 
 - The suffix contains an input question that the agent should answer using information obtained from the database. 
 - It also includes an agent scratchpad where any notes or thoughts can be written down while constructing the query. 
```
[0m
2023-04-29 18:11:26 - PARSERO - [32m[40mINFO[0m - File:planner_prompt.py_chunk_60-80
Code:
Begin!
Plan: {input}
Thought:
{agent_scratchpad}
"""
API_CONTROLLER_TOOL_NAME = "api_controller"
API_CONTROLLER_TOOL_DESCRIPTION = f"Can be used to execute a plan of API calls, like {API_CONTROLLER_TOOL_NAME}(plan)."
API_ORCHESTRATOR_PROMPT = """You are an agent that assists with user queries against API, things like querying information or creating resources.
Some user queries can be resolved in a single API call, particularly if you can find appropriate params from the OpenAPI spec; though some require several API call.
You should always plan your API calls first, and then execute the plan second.
If the plan includes a DELETE call, be sure to ask the User for authorization first unless the User has specifically asked to delete something.
You should never return information without executing the api_controller tool.
Here are the tools to plan and execute API requests: {tool_descriptions}
Starting below, you should follow this format:
User query: the query a User wants help with related to the API
Thought: you should always think about what to do
Action: the action to take, should be one of the tools [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Summary:
A Python file that contains a prompt for the user to plan their API calls
 - Includes tools to help with planning and executing API requests
 - Contains descriptions of each tool, as well as instructions on how to use them 
```
[0m
2023-04-29 18:11:26 - PARSERO - [32m[40mINFO[0m - File:planner_prompt.py_chunk_40-60
Code:
User query: {query}
Plan:"""
API_PLANNER_TOOL_NAME = "api_planner"
API_PLANNER_TOOL_DESCRIPTION = f"Can be used to generate the right API calls to assist with a user query, like {API_PLANNER_TOOL_NAME}(query). Should always be called before trying to call the API controller."
API_CONTROLLER_PROMPT = """You are an agent that gets a sequence of API calls and given their documentation, should execute them and return the final response.
If you cannot complete them and run into issues, you should explain the issue. If you're able to resolve an API call, you can retry the API call. When interacting with API objects, you should extract ids for inputs to other API calls but ids and names for outputs returned to the User.
Here is documentation on the API:
Base url: {api_url}
Endpoints:
{api_docs}
Here are tools to execute requests against the API: {tool_descriptions}
Starting below, you should follow this format:
Plan: the plan of API calls to execute
Thought: you should always think about what to do
Action: the action to take, should be one of the tools [{tool_names}]
Action Input: the input to the action
Observation: the output of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I am finished executing the plan (or, I cannot finish executing the plan without knowing some other information.)
Final Answer: the final output from executing the plan or missing information I'd need to re-plan correctly.
Summary:
Generates the right API calls to assist with a user query
 - Executes requests against an API using specified tools
 - Extracts ids for inputs and names/ids for outputs returned to the User
 - Follows a Thought/Action/Action Input/Observation format when interacting with APIs
```
[0m
2023-04-29 18:11:26 - PARSERO - [32m[40mINFO[0m - File:prompt.py_chunk_0-20
Code:
PREFIX = """Answer the following questions as best you can. You have access to the following tools:"""
FORMAT_INSTRUCTIONS = """The way you use the tools is by specifying a json blob.
Specifically, this json should have a `action` key (with the name of the tool to use) and a `action_input` key (with the input to the tool going here).
The only values that should be in the "action" field are: {tool_names}
The $JSON_BLOB should only contain a SINGLE action, do NOT return a list of multiple actions. Here is an example of a valid $JSON_BLOB:
```
{{{{
  "action": $TOOL_NAME,
  "action_input": $INPUT
}}}}
```
ALWAYS use the following format:
Question: the input question you must answer
Thought: you should always think about what to do
Action:
```
$JSON_BLOB
```
Observation: the result of the action
... (this Thought/Action/Observation can repeat N times)
Summary:
Prompt.py is a file within the project directory that contains code for creating and managing conversations with users. 
 - It includes functions to create prompts, parse user input, and respond accordingly. 
 - The file also contains methods for handling errors in user input as well as providing helpful hints when needed. 
 - Additionally, it provides support for natural language processing (NLP) tasks such as sentiment analysis and entity extraction. ```
[0m
2023-04-29 18:11:26 - PARSERO - [32m[40mINFO[0m - File:planner_prompt.py_chunk_0-20
Code:
from langchain.prompts.prompt import PromptTemplate
API_PLANNER_PROMPT = """You are a planner that plans a sequence of API calls to assist with user queries against an API.
You should:
1) evaluate whether the user query can be solved by the API documentated below. If no, say why.
2) if yes, generate a plan of API calls and say what they are doing step by step.
3) If the plan includes a DELETE call, you should always return an ask from the User for authorization first unless the User has specifically asked to delete something.
You should only use API endpoints documented below ("Endpoints you can use:").
You can only use the DELETE tool if the User has specifically asked to delete something. Otherwise, you should return a request authorization from the User first.
Some user queries can be resolved in a single API call, but some will require several API calls.
The plan will be passed to an API controller that can format it into web requests and return the responses.
----
Here are some examples:
Fake endpoints for examples:
GET /user to get information about the current user
GET /products/search search across products
POST /users/{{id}}/cart to add products to a user's cart
PATCH /users/{{id}}/cart to update a user's cart
DELETE /users/{{id}}/cart to delete a user's cart
User query: tell me a joke
Plan: Sorry, this API's domain is shopping, not comedy.
Summary:
PromptTemplate class is used to define a prompt template for the planner
 - The API_PLANNER_PROMPT defines a prompt that asks the user to plan an API call sequence in order to solve their query
 - Examples of fake endpoints are provided, such as GET /user, POST /users/{{id}}/cart and DELETE /users/{{id}}/cart 
 - Instructions on how to generate a plan are given, including evaluating whether the user query can be solved by the API documentated below and generating a plan of API calls step-by-step 
 - It also specifies that if the plan includes a DELETE call, you should always return an ask from the User for authorization first unless they have specifically asked to delete something.```
[0m
2023-04-29 18:13:12 - PARSERO - [32m[40mINFO[0m - Getting embeddings[0m
2023-04-29 18:13:12 - PARSERO - [32m[40mINFO[0m - Calculating summary similarities[0m
2023-04-29 18:13:12 - PARSERO - [32m[40mINFO[0m - Calculating code similarities[0m
2023-04-29 18:13:13 - PARSERO - [32m[40mINFO[0m - File:agent.py_chunk_620-640
Code:
            return output
        actions: List[AgentAction]
        if isinstance(output, AgentAction):
            actions = [output]
        else:
            actions = output
        async def _aperform_agent_action(
            agent_action: AgentAction,
        ) -> Tuple[AgentAction, str]:
            if self.callback_manager.is_async:
                await self.callback_manager.on_agent_action(
                    agent_action, verbose=self.verbose, color="green"
                )
            else:
                self.callback_manager.on_agent_action(
                    agent_action, verbose=self.verbose, color="green"
                )
            if agent_action.tool in name_to_tool_map:
                tool = name_to_tool_map[agent_action.tool]
                return_direct = tool.return_direct
Summary:
Contains code for an Agent class, which is used to interact with the environment
 - Includes methods for performing agent actions and handling callbacks
 - Defines a mapping between tool names and their corresponding classes  ```
[0m
2023-04-29 18:13:13 - PARSERO - [32m[40mINFO[0m - File:wiki_prompt.py_chunk_20-40
Code:
Observation: Milhouse Mussolini Van Houten is a recurring character in the Fox animated television series The Simpsons voiced by Pamela Hayden and created by Matt Groening.
Thought: The paragraph does not tell who Milhouse is named after, maybe I can look up "named after".
Action: Lookup[named after]
Observation: (Result 1 / 1) Milhouse was named after U.S. president Richard Nixon, whose middle name was Milhous.
Thought: Milhouse was named after U.S. president Richard Nixon, so the answer is Richard Nixon.
Action: Finish[Richard Nixon]""",
    """Question: Which documentary is about Finnish rock groups, Adam Clayton Powell or The Saimaa Gesture?
Thought: I need to search Adam Clayton Powell and The Saimaa Gesture, and find which documentary is about Finnish rock groups.
Action: Search[Adam Clayton Powell]
Observation: Could not find [Adam Clayton Powell]. Similar: [â€™Adam Clayton Powell IIIâ€™, â€™Seventh Avenue (Manhattan)â€™, â€™Adam Clayton Powell Jr. State Office Buildingâ€™, â€™Isabel Washington Powellâ€™, â€™Adam Powellâ€™, â€™Adam Clayton Powell (film)â€™, â€™Giancarlo Espositoâ€™].
Thought: To find the documentary, I can search Adam Clayton Powell (film).
Action: Search[Adam Clayton Powell (film)]
Observation: Adam Clayton Powell is a 1989 American documentary film directed by Richard Kilberg. The film is about the rise and fall of influential African-American politician Adam Clayton Powell Jr.[3][4] It was later aired as part of the PBS series The American Experience.
Thought: Adam Clayton Powell (film) is a documentary about an African-American politician, not Finnish rock groups. So the documentary about Finnish rock groups must instead be The Saimaa Gesture.
Action: Finish[The Saimaa Gesture]""",
    """Question: What profession does Nicholas Ray and Elia Kazan have in common?
Thought: I need to search Nicholas Ray and Elia Kazan, find their professions, then find the profession they have in common.
Action: Search[Nicholas Ray]
Observation: Nicholas Ray (born Raymond Nicholas Kienzle Jr., August 7, 1911 - June 16, 1979) was an American film director, screenwriter, and actor best known for the 1955 film Rebel Without a Cause.
Thought: Professions of Nicholas Ray are director, screenwriter, and actor. I need to search Elia Kazan next and find his professions.
Summary:
A Python file that contains a React-based Wiki Prompt agent
 - The agent is used to generate natural language responses from user input
 - It uses the spaCy library for natural language processing and text analysis 
 - It also uses the GPT-2 model for generating responses 
 - The codebase includes functions for tokenizing, lemmatizing, and tagging words in user input ```
[0m
2023-04-29 18:13:13 - PARSERO - [32m[40mINFO[0m - File:planner_prompt.py_chunk_60-80
Code:
Begin!
Plan: {input}
Thought:
{agent_scratchpad}
"""
API_CONTROLLER_TOOL_NAME = "api_controller"
API_CONTROLLER_TOOL_DESCRIPTION = f"Can be used to execute a plan of API calls, like {API_CONTROLLER_TOOL_NAME}(plan)."
API_ORCHESTRATOR_PROMPT = """You are an agent that assists with user queries against API, things like querying information or creating resources.
Some user queries can be resolved in a single API call, particularly if you can find appropriate params from the OpenAPI spec; though some require several API call.
You should always plan your API calls first, and then execute the plan second.
If the plan includes a DELETE call, be sure to ask the User for authorization first unless the User has specifically asked to delete something.
You should never return information without executing the api_controller tool.
Here are the tools to plan and execute API requests: {tool_descriptions}
Starting below, you should follow this format:
User query: the query a User wants help with related to the API
Thought: you should always think about what to do
Action: the action to take, should be one of the tools [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Summary:
A Python file that contains a prompt for the user to plan their API calls
 - Includes tools to help with planning and executing API requests
 - Contains descriptions of each tool, as well as instructions on how to use them 
```
[0m
2023-04-29 18:13:13 - PARSERO - [32m[40mINFO[0m - File:textworld_prompt.py_chunk_20-40
Code:
be empty. If you haven't noticed it already, there seems to be something there
by the wall, it's a table. Unfortunately, there isn't a thing on it. Hm. Oh well
There is an exit to the west. Don't worry, it is unguarded.
Thought: I need to take the binder from the locker
Action: Play[take binder]
Observation: You take the binder from the locker.
Thought: I need to place the binder on the mantelpiece
Action: Play[put binder on mantelpiece]
Observation: You put the binder on the mantelpiece.
Your score has just gone up by one point.
*** The End ***
Thought: The End has occurred
Action: Finish[yes]
"""
]
SUFFIX = """\n\nSetup: {input}
{agent_scratchpad}"""
TEXTWORLD_PROMPT = PromptTemplate.from_examples(
    EXAMPLES, SUFFIX, ["input", "agent_scratchpad"]
)
Summary:
It is a Python file located in the langchain/agents/react directory.
 - The file contains code for creating PromptTemplate objects from examples, suffixes and input parameters. 
 - It also includes functions to generate text-based prompts based on user inputs. ```
[0m
2023-04-29 18:13:13 - PARSERO - [32m[40mINFO[0m - File:agent.py_chunk_520-540
Code:
        """Return the singular output key.
        :meta private:
        """
        if self.return_intermediate_steps:
            return self.agent.return_values + ["intermediate_steps"]
        else:
            return self.agent.return_values
    def lookup_tool(self, name: str) -> BaseTool:
        """Lookup tool by name."""
        return {tool.name: tool for tool in self.tools}[name]
    def _should_continue(self, iterations: int, time_elapsed: float) -> bool:
        if self.max_iterations is not None and iterations >= self.max_iterations:
            return False
        if (
            self.max_execution_time is not None
            and time_elapsed >= self.max_execution_time
        ):
            return False
        return True
    def _return(self, output: AgentFinish, intermediate_steps: list) -> Dict[str, Any]:
Summary:
Defines the Agent class, which is used to optimize and analyze a codebase
 - Contains methods for returning values, looking up tools by name, and determining whether or not to continue execution
 - Includes logic for handling intermediate steps in the optimization process 
```
[0m
2023-04-29 18:13:13 - PARSERO - [32m[40mINFO[0m - File:prompt.py
Code:
# flake8: noqa

PREFIX = """You are an agent designed to write and execute python code to answer questions.
You have access to a python REPL, which you can use to execute python code.
If you get an error, debug your code and try again.
Only use the output of your code to answer the question. 
You might know the answer without running any code, but you should still run the code to get the answer.
If it does not seem like you can write code to answer the question, just return "I don't know" as the answer.
"""

Summary:
Contains a SQL_PREFIX and SQL_SUFFIX string which provide instructions for the agent to interact with a SQL database.
 - The prefix provides instructions on how to create syntactically correct queries, limit results, order results by relevant columns, and not query all columns from a specific table. 
 - The suffix contains an input question that the agent should answer using information obtained from the database. 
 - It also includes an agent scratchpad where any notes or thoughts can be written down while constructing the query. 
```
[0m
2023-04-29 18:13:13 - PARSERO - [32m[40mINFO[0m - File:prompt.py_chunk_0-20
Code:
PREFIX = """Assistant is a large language model trained by OpenAI.
Assistant is designed to be able to assist with a wide range of tasks, from answering simple questions to providing in-depth explanations and discussions on a wide range of topics. As a language model, Assistant is able to generate human-like text based on the input it receives, allowing it to engage in natural-sounding conversations and provide responses that are coherent and relevant to the topic at hand.
Assistant is constantly learning and improving, and its capabilities are constantly evolving. It is able to process and understand large amounts of text, and can use this knowledge to provide accurate and informative responses to a wide range of questions. Additionally, Assistant is able to generate its own text based on the input it receives, allowing it to engage in discussions and provide explanations and descriptions on a wide range of topics.
Overall, Assistant is a powerful system that can help with a wide range of tasks and provide valuable insights and information on a wide range of topics. Whether you need help with a specific question or just want to have a conversation about a particular topic, Assistant is here to assist."""
FORMAT_INSTRUCTIONS = """RESPONSE FORMAT INSTRUCTIONS
----------------------------
When responding to me please, please output a response in one of two formats:
**Option 1:**
Use this if you want the human to use a tool.
Markdown code snippet formatted in the following schema:
```json
{{{{
    "action": string \\ The action to take. Must be one of {tool_names}
    "action_input": string \\ The input to the action
}}}}
```
**Option #2:**
Use this if you want to respond directly to the human. Markdown code snippet formatted in the following schema:
```json
{{{{
Summary:
Prompt.py is a file within the project directory that contains code for creating and managing conversations with users. 
 - It includes functions to create prompts, parse user input, and respond accordingly. 
 - The file also contains methods for handling errors in user input as well as providing helpful hints when needed. 
 - Additionally, it provides support for natural language processing (NLP) tasks such as sentiment analysis and entity extraction. ```
[0m
2023-04-29 18:13:13 - PARSERO - [32m[40mINFO[0m - File:prompt.py_chunk_0-20
Code:
PREFIX = """Answer the following questions as best you can. You have access to the following tools:"""
FORMAT_INSTRUCTIONS = """The way you use the tools is by specifying a json blob.
Specifically, this json should have a `action` key (with the name of the tool to use) and a `action_input` key (with the input to the tool going here).
The only values that should be in the "action" field are: {tool_names}
The $JSON_BLOB should only contain a SINGLE action, do NOT return a list of multiple actions. Here is an example of a valid $JSON_BLOB:
```
{{{{
  "action": $TOOL_NAME,
  "action_input": $INPUT
}}}}
```
ALWAYS use the following format:
Question: the input question you must answer
Thought: you should always think about what to do
Action:
```
$JSON_BLOB
```
Observation: the result of the action
... (this Thought/Action/Observation can repeat N times)
Summary:
Prompt.py is a file within the project directory that contains code for creating and managing conversations with users. 
 - It includes functions to create prompts, parse user input, and respond accordingly. 
 - The file also contains methods for handling errors in user input as well as providing helpful hints when needed. 
 - Additionally, it provides support for natural language processing (NLP) tasks such as sentiment analysis and entity extraction. ```
[0m
2023-04-29 18:13:13 - PARSERO - [32m[40mINFO[0m - File:planner_prompt.py_chunk_40-60
Code:
User query: {query}
Plan:"""
API_PLANNER_TOOL_NAME = "api_planner"
API_PLANNER_TOOL_DESCRIPTION = f"Can be used to generate the right API calls to assist with a user query, like {API_PLANNER_TOOL_NAME}(query). Should always be called before trying to call the API controller."
API_CONTROLLER_PROMPT = """You are an agent that gets a sequence of API calls and given their documentation, should execute them and return the final response.
If you cannot complete them and run into issues, you should explain the issue. If you're able to resolve an API call, you can retry the API call. When interacting with API objects, you should extract ids for inputs to other API calls but ids and names for outputs returned to the User.
Here is documentation on the API:
Base url: {api_url}
Endpoints:
{api_docs}
Here are tools to execute requests against the API: {tool_descriptions}
Starting below, you should follow this format:
Plan: the plan of API calls to execute
Thought: you should always think about what to do
Action: the action to take, should be one of the tools [{tool_names}]
Action Input: the input to the action
Observation: the output of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Thought: I am finished executing the plan (or, I cannot finish executing the plan without knowing some other information.)
Final Answer: the final output from executing the plan or missing information I'd need to re-plan correctly.
Summary:
Generates the right API calls to assist with a user query
 - Executes requests against an API using specified tools
 - Extracts ids for inputs and names/ids for outputs returned to the User
 - Follows a Thought/Action/Action Input/Observation format when interacting with APIs
```
[0m
2023-04-29 18:13:13 - PARSERO - [32m[40mINFO[0m - File:planner_prompt.py_chunk_60-80
Code:
Begin!
Plan: {input}
Thought:
{agent_scratchpad}
"""
API_CONTROLLER_TOOL_NAME = "api_controller"
API_CONTROLLER_TOOL_DESCRIPTION = f"Can be used to execute a plan of API calls, like {API_CONTROLLER_TOOL_NAME}(plan)."
API_ORCHESTRATOR_PROMPT = """You are an agent that assists with user queries against API, things like querying information or creating resources.
Some user queries can be resolved in a single API call, particularly if you can find appropriate params from the OpenAPI spec; though some require several API call.
You should always plan your API calls first, and then execute the plan second.
If the plan includes a DELETE call, be sure to ask the User for authorization first unless the User has specifically asked to delete something.
You should never return information without executing the api_controller tool.
Here are the tools to plan and execute API requests: {tool_descriptions}
Starting below, you should follow this format:
User query: the query a User wants help with related to the API
Thought: you should always think about what to do
Action: the action to take, should be one of the tools [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Summary:
A Python file that contains a prompt for the user to plan their API calls
 - Includes tools to help with planning and executing API requests
 - Contains descriptions of each tool, as well as instructions on how to use them 
```
[0m
2023-04-29 18:14:20 - PARSERO - [32m[40mINFO[0m - Getting embeddings[0m
2023-04-29 18:14:21 - PARSERO - [32m[40mINFO[0m - Calculating summary similarities[0m
2023-04-29 18:14:21 - PARSERO - [32m[40mINFO[0m - Calculating code similarities[0m
2023-04-29 18:14:21 - PARSERO - [32m[40mINFO[0m - File:base.py
Code:
"""Python agent."""

from typing import Any, Optional

from langchain.agents.agent import AgentExecutor
Summary:
Implements the AgentExecutor class, which is responsible for executing an agent
 - Defines a create_python_agent() function that takes in an LLM and PythonREPLTool object to construct a python agent
 - Uses ZeroShotAgent.create_prompt() to generate a prompt from the given tools 
 - Constructs an LLMChain with the given LLM and prompt 
 - Creates a ZeroShotAgent using the allowed tools and other keyword arguments 
[0m
2023-04-29 18:14:21 - PARSERO - [32m[40mINFO[0m - File:prompt.py
Code:
# flake8: noqa

PREFIX = """You are an agent designed to write and execute python code to answer questions.
You have access to a python REPL, which you can use to execute python code.
If you get an error, debug your code and try again.
Summary:
Uses a moving window approach to chunk the code
 - Contains functions for prompting user input and validating it 
 - Includes logic for handling errors in user input 
 - Utilizes Python REPL to execute python code
[0m
2023-04-29 18:14:21 - PARSERO - [32m[40mINFO[0m - File:prompt.py
Code:
# flake8: noqa

PREFIX = """You are an agent designed to write and execute python code to answer questions.
You have access to a python REPL, which you can use to execute python code.
If you get an error, debug your code and try again.
Summary:
Uses a moving window approach to chunk the code
 - Contains functions for prompting user input and validating it 
 - Includes logic for handling errors in user input 
 - Utilizes Python REPL to execute python code
[0m
2023-04-29 18:14:44 - PARSERO - [32m[40mINFO[0m - Getting embeddings[0m
2023-04-29 18:14:44 - PARSERO - [32m[40mINFO[0m - Getting embeddings[0m
2023-04-29 18:14:45 - PARSERO - [32m[40mINFO[0m - Calculating summary similarities[0m
2023-04-29 18:14:45 - PARSERO - [32m[40mINFO[0m - Calculating summary similarities[0m
2023-04-29 18:14:45 - PARSERO - [32m[40mINFO[0m - Calculating code similarities[0m
2023-04-29 18:14:45 - PARSERO - [32m[40mINFO[0m - Calculating code similarities[0m
2023-04-29 18:14:45 - PARSERO - [32m[40mINFO[0m - File:prompt.py
Code:
# flake8: noqa

PREFIX = """You are an agent designed to write and execute python code to answer questions.
You have access to a python REPL, which you can use to execute python code.
If you get an error, debug your code and try again.
Summary:
Uses a moving window approach to chunk the code
 - Contains functions for prompting user input and validating it 
 - Includes logic for handling errors in user input 
 - Utilizes Python REPL to execute python code
[0m
2023-04-29 18:14:45 - PARSERO - [32m[40mINFO[0m - File:prompt.py
Code:
# flake8: noqa

PREFIX = """You are an agent designed to write and execute python code to answer questions.
You have access to a python REPL, which you can use to execute python code.
If you get an error, debug your code and try again.
Summary:
Uses a moving window approach to chunk the code
 - Contains functions for prompting user input and validating it 
 - Includes logic for handling errors in user input 
 - Utilizes Python REPL to execute python code
[0m
2023-04-29 18:14:45 - PARSERO - [32m[40mINFO[0m - File:base.py
Code:
"""Python agent."""

from typing import Any, Optional

from langchain.agents.agent import AgentExecutor
Summary:
Implements the AgentExecutor class, which is responsible for executing an agent
 - Defines a create_python_agent() function that takes in an LLM and PythonREPLTool object to construct a python agent
 - Uses ZeroShotAgent.create_prompt() to generate a prompt from the given tools 
 - Constructs an LLMChain with the given LLM and prompt 
 - Creates a ZeroShotAgent using the allowed tools and other keyword arguments 
[0m
2023-04-29 18:14:45 - PARSERO - [32m[40mINFO[0m - File:base.py
Code:
"""Python agent."""

from typing import Any, Optional

from langchain.agents.agent import AgentExecutor
Summary:
Implements the AgentExecutor class, which is responsible for executing an agent
 - Defines a create_python_agent() function that takes in an LLM and PythonREPLTool object to construct a python agent
 - Uses ZeroShotAgent.create_prompt() to generate a prompt from the given tools 
 - Constructs an LLMChain with the given LLM and prompt 
 - Creates a ZeroShotAgent using the allowed tools and other keyword arguments 
[0m
2023-04-29 18:14:45 - PARSERO - [32m[40mINFO[0m - File:prompt.py
Code:
# flake8: noqa

PREFIX = """You are an agent designed to write and execute python code to answer questions.
You have access to a python REPL, which you can use to execute python code.
If you get an error, debug your code and try again.
Summary:
Uses a moving window approach to chunk the code
 - Contains functions for prompting user input and validating it 
 - Includes logic for handling errors in user input 
 - Utilizes Python REPL to execute python code
[0m
2023-04-29 18:14:45 - PARSERO - [32m[40mINFO[0m - File:prompt.py
Code:
# flake8: noqa

PREFIX = """You are an agent designed to write and execute python code to answer questions.
You have access to a python REPL, which you can use to execute python code.
If you get an error, debug your code and try again.
Summary:
Uses a moving window approach to chunk the code
 - Contains functions for prompting user input and validating it 
 - Includes logic for handling errors in user input 
 - Utilizes Python REPL to execute python code
[0m
2023-04-29 20:46:41 - PARSERO - [32m[40mINFO[0m - Getting embeddings[0m
2023-04-29 20:46:41 - PARSERO - [32m[40mINFO[0m - Getting embeddings[0m
2023-04-29 20:46:41 - PARSERO - [32m[40mINFO[0m - Getting embeddings[0m
2023-04-29 20:46:42 - PARSERO - [32m[40mINFO[0m - Calculating summary similarities[0m
2023-04-29 20:46:42 - PARSERO - [32m[40mINFO[0m - Calculating summary similarities[0m
2023-04-29 20:46:42 - PARSERO - [32m[40mINFO[0m - Calculating summary similarities[0m
2023-04-29 20:46:42 - PARSERO - [32m[40mINFO[0m - Calculating code similarities[0m
2023-04-29 20:46:42 - PARSERO - [32m[40mINFO[0m - Calculating code similarities[0m
2023-04-29 20:46:42 - PARSERO - [32m[40mINFO[0m - Calculating code similarities[0m
2023-04-29 20:46:42 - PARSERO - [32m[40mINFO[0m - File:base.py
Code:
"""Python agent."""

from typing import Any, Optional

from langchain.agents.agent import AgentExecutor
Summary:
Implements the AgentExecutor class, which is responsible for executing an agent
 - Defines a create_python_agent() function that takes in an LLM and PythonREPLTool object to construct a python agent
 - Uses ZeroShotAgent.create_prompt() to generate a prompt from the given tools 
 - Constructs an LLMChain with the given LLM and prompt 
 - Creates a ZeroShotAgent using the allowed tools and other keyword arguments 
[0m
2023-04-29 20:46:42 - PARSERO - [32m[40mINFO[0m - File:base.py
Code:
"""Python agent."""

from typing import Any, Optional

from langchain.agents.agent import AgentExecutor
Summary:
Implements the AgentExecutor class, which is responsible for executing an agent
 - Defines a create_python_agent() function that takes in an LLM and PythonREPLTool object to construct a python agent
 - Uses ZeroShotAgent.create_prompt() to generate a prompt from the given tools 
 - Constructs an LLMChain with the given LLM and prompt 
 - Creates a ZeroShotAgent using the allowed tools and other keyword arguments 
[0m
2023-04-29 20:46:42 - PARSERO - [32m[40mINFO[0m - File:base.py
Code:
"""Python agent."""

from typing import Any, Optional

from langchain.agents.agent import AgentExecutor
Summary:
Implements the AgentExecutor class, which is responsible for executing an agent
 - Defines a create_python_agent() function that takes in an LLM and PythonREPLTool object to construct a python agent
 - Uses ZeroShotAgent.create_prompt() to generate a prompt from the given tools 
 - Constructs an LLMChain with the given LLM and prompt 
 - Creates a ZeroShotAgent using the allowed tools and other keyword arguments 
[0m
2023-04-29 20:46:42 - PARSERO - [32m[40mINFO[0m - File:prompt.py
Code:
# flake8: noqa

PREFIX = """You are an agent designed to write and execute python code to answer questions.
You have access to a python REPL, which you can use to execute python code.
If you get an error, debug your code and try again.
Summary:
Uses a moving window approach to chunk the code
 - Contains functions for prompting user input and validating it 
 - Includes logic for handling errors in user input 
 - Utilizes Python REPL to execute python code
[0m
2023-04-29 20:46:42 - PARSERO - [32m[40mINFO[0m - File:prompt.py
Code:
# flake8: noqa

PREFIX = """You are an agent designed to write and execute python code to answer questions.
You have access to a python REPL, which you can use to execute python code.
If you get an error, debug your code and try again.
Summary:
Uses a moving window approach to chunk the code
 - Contains functions for prompting user input and validating it 
 - Includes logic for handling errors in user input 
 - Utilizes Python REPL to execute python code
[0m
2023-04-29 20:46:42 - PARSERO - [32m[40mINFO[0m - File:prompt.py
Code:
# flake8: noqa

PREFIX = """You are an agent designed to write and execute python code to answer questions.
You have access to a python REPL, which you can use to execute python code.
If you get an error, debug your code and try again.
Summary:
Uses a moving window approach to chunk the code
 - Contains functions for prompting user input and validating it 
 - Includes logic for handling errors in user input 
 - Utilizes Python REPL to execute python code
[0m
2023-04-29 20:46:42 - PARSERO - [32m[40mINFO[0m - File:base.py
Code:
"""Python agent."""

from typing import Any, Optional

from langchain.agents.agent import AgentExecutor
Summary:
Implements the AgentExecutor class, which is responsible for executing an agent
 - Defines a create_python_agent() function that takes in an LLM and PythonREPLTool object to construct a python agent
 - Uses ZeroShotAgent.create_prompt() to generate a prompt from the given tools 
 - Constructs an LLMChain with the given LLM and prompt 
 - Creates a ZeroShotAgent using the allowed tools and other keyword arguments 
[0m
2023-04-29 20:46:42 - PARSERO - [32m[40mINFO[0m - File:base.py
Code:
"""Python agent."""

from typing import Any, Optional

from langchain.agents.agent import AgentExecutor
Summary:
Implements the AgentExecutor class, which is responsible for executing an agent
 - Defines a create_python_agent() function that takes in an LLM and PythonREPLTool object to construct a python agent
 - Uses ZeroShotAgent.create_prompt() to generate a prompt from the given tools 
 - Constructs an LLMChain with the given LLM and prompt 
 - Creates a ZeroShotAgent using the allowed tools and other keyword arguments 
[0m
2023-04-29 20:46:42 - PARSERO - [32m[40mINFO[0m - File:base.py
Code:
"""Python agent."""

from typing import Any, Optional

from langchain.agents.agent import AgentExecutor
Summary:
Implements the AgentExecutor class, which is responsible for executing an agent
 - Defines a create_python_agent() function that takes in an LLM and PythonREPLTool object to construct a python agent
 - Uses ZeroShotAgent.create_prompt() to generate a prompt from the given tools 
 - Constructs an LLMChain with the given LLM and prompt 
 - Creates a ZeroShotAgent using the allowed tools and other keyword arguments 
[0m
2023-04-29 20:49:52 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 20:49:53 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 20:49:53 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 20:49:53 - PARSERO - [32m[47mINFO[0m - File:agent_types.py
Code:
from enum import Enum


class AgentType(str, Enum):
    ZERO_SHOT_REACT_DESCRIPTION = "zero-shot-react-description"
    REACT_DOCSTORE = "react-docstore"
    SELF_ASK_WITH_SEARCH = "self-ask-with-search"
    CONVERSATIONAL_REACT_DESCRIPTION = "conversational-react-description"
    CHAT_ZERO_SHOT_REACT_DESCRIPTION = "chat-zero-shot-react-description"
    CHAT_CONVERSATIONAL_REACT_DESCRIPTION = "chat-conversational-react-description"
    CHAT_ZERO_SHOT_REACT_DESCRIPTION_V2 = "chat-zero-shot-react-description-002"

Summary:
Defines an Enum class called AgentType
 - Contains 6 different types of agents: 
    - Zero-Shot React Description 
    - React Docstore 
    - Self Ask with Search 
    - Conversational React Description 
    - Chat Zero Shot React Description  
    - Chat Conversational React Description  
```
[0m
2023-04-29 20:49:53 - PARSERO - [32m[47mINFO[0m - File:initialize.py_chunk_20-40
Code:
        llm: Language model to use as the agent.
        agent: Agent type to use. If None and agent_path is also None, will default to
            AgentType.ZERO_SHOT_REACT_DESCRIPTION.
        callback_manager: CallbackManager to use. Global callback manager is used if
            not provided. Defaults to None.
        agent_path: Path to serialized agent to use.
        agent_kwargs: Additional key word arguments to pass to the underlying agent
        **kwargs: Additional key word arguments passed to the agent executor
    Returns:
        An agent executor
    """
    if agent is None and agent_path is None:
        agent = AgentType.ZERO_SHOT_REACT_DESCRIPTION
    if agent is not None and agent_path is not None:
        raise ValueError(
            "Both `agent` and `agent_path` are specified, "
            "but at most only one should be."
        )
    if agent is not None:
        if agent not in AGENT_TO_CLASS:
Summary:
Defines the AgentType class, which is used to specify the type of agent to use
 - Contains a dictionary mapping each agent type to its corresponding class
 - Provides a function for initializing an agent executor with specified parameters 
 - Allows for specifying either an existing serialized agent or creating one from scratch 
 - Accepts additional keyword arguments that are passed on to the underlying agent ```
[0m
2023-04-29 20:49:53 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_620-640
Code:
            return output
        actions: List[AgentAction]
        if isinstance(output, AgentAction):
            actions = [output]
        else:
            actions = output
        async def _aperform_agent_action(
            agent_action: AgentAction,
        ) -> Tuple[AgentAction, str]:
            if self.callback_manager.is_async:
                await self.callback_manager.on_agent_action(
                    agent_action, verbose=self.verbose, color="green"
                )
            else:
                self.callback_manager.on_agent_action(
                    agent_action, verbose=self.verbose, color="green"
                )
            if agent_action.tool in name_to_tool_map:
                tool = name_to_tool_map[agent_action.tool]
                return_direct = tool.return_direct
Summary:
Contains code for an Agent class, which is used to interact with the environment
 - Includes methods for performing agent actions and handling callbacks
 - Defines a mapping between tool names and their corresponding classes  ```
[0m
2023-04-29 20:49:53 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_540-560
Code:
        self.callback_manager.on_agent_finish(
            output, color="green", verbose=self.verbose
        )
        final_output = output.return_values
        if self.return_intermediate_steps:
            final_output["intermediate_steps"] = intermediate_steps
        return final_output
    async def _areturn(
        self, output: AgentFinish, intermediate_steps: list
    ) -> Dict[str, Any]:
        if self.callback_manager.is_async:
            await self.callback_manager.on_agent_finish(
                output, color="green", verbose=self.verbose
            )
        else:
            self.callback_manager.on_agent_finish(
                output, color="green", verbose=self.verbose
            )
        final_output = output.return_values
        if self.return_intermediate_steps:
Summary:
Contains the Agent class, which is responsible for running agents
 - Includes methods to run and return agent output
 - Has a callback manager that can be used to handle asynchronous calls
 - Allows users to specify whether or not they want intermediate steps returned in the final output ```
[0m
2023-04-29 20:49:53 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_40-60
Code:
    ) -> Union[AgentAction, AgentFinish]:
        """Given input, decided what to do.
        Args:
            intermediate_steps: Steps the LLM has taken to date,
                along with observations
            **kwargs: User inputs.
        Returns:
            Action specifying what tool to use.
        """
    @abstractmethod
    async def aplan(
        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any
    ) -> Union[AgentAction, AgentFinish]:
        """Given input, decided what to do.
        Args:
            intermediate_steps: Steps the LLM has taken to date,
                along with observations
            **kwargs: User inputs.
        Returns:
            Action specifying what tool to use.
Summary:
Contains the abstract class Agent, which is used to define an agent's behavior in a language learning environment.
 - Includes two methods: act() and aplan(), both of which take user inputs as arguments and return either an action or finish signal. 
 - The act() method takes intermediate steps taken by the LLM (Language Learning Model) along with observations as input, while the aplan() method takes user inputs as arguments. 
```
[0m
2023-04-29 20:49:53 - PARSERO - [32m[47mINFO[0m - File:__init__.py_chunk_0-20
Code:
"""Interface for agents."""
from langchain.agents.agent import (
    Agent,
    AgentExecutor,
    AgentOutputParser,
    BaseMultiActionAgent,
    BaseSingleActionAgent,
    LLMSingleActionAgent,
)
from langchain.agents.agent_toolkits import (
    create_csv_agent,
    create_json_agent,
    create_openapi_agent,
    create_pandas_dataframe_agent,
    create_sql_agent,
    create_vectorstore_agent,
    create_vectorstore_router_agent,
)
from langchain.agents.agent_types import AgentType
from langchain.agents.conversational.base import ConversationalAgent
Summary:
Create CSV Agent
 - Create JSON Agent
 - JsonToolkit for manipulating JSON data
 - NLAToolkit for Natural Language Processing tasks 
 - Create OpenAPI Agent 
 - OpenAPIToolkit to interact with APIs 
 - Create Pandas Dataframe Agent 
 - Create Python Agent  
- SQLDatabaseToolkit to manipulate databases and tables in SQL format 
- VectorStoreInfo class to store vectorized data  
- VectorStoreRouterToolkit to route requests between different vector stores   					    	     	      	       	        	          VectorStoreToolkit for interacting with the vector store.```
[0m
2023-04-29 20:49:53 - PARSERO - [32m[47mINFO[0m - File:__init__.py_chunk_0-20
Code:
"""Agent toolkits."""
from langchain.agents.agent_toolkits.csv.base import create_csv_agent
from langchain.agents.agent_toolkits.json.base import create_json_agent
from langchain.agents.agent_toolkits.json.toolkit import JsonToolkit
from langchain.agents.agent_toolkits.nla.toolkit import NLAToolkit
from langchain.agents.agent_toolkits.openapi.base import create_openapi_agent
from langchain.agents.agent_toolkits.openapi.toolkit import OpenAPIToolkit
from langchain.agents.agent_toolkits.pandas.base import create_pandas_dataframe_agent
from langchain.agents.agent_toolkits.python.base import create_python_agent
from langchain.agents.agent_toolkits.sql.base import create_sql_agent
from langchain.agents.agent_toolkits.sql.toolkit import SQLDatabaseToolkit
from langchain.agents.agent_toolkits.vectorstore.base import (
    create_vectorstore_agent,
    create_vectorstore_router_agent,
)
from langchain.agents.agent_toolkits.vectorstore.toolkit import (
    VectorStoreInfo,
    VectorStoreRouterToolkit,
    VectorStoreToolkit,
)
Summary:
Create CSV Agent
 - Create JSON Agent
 - JsonToolkit for manipulating JSON data
 - NLAToolkit for Natural Language Processing tasks 
 - Create OpenAPI Agent 
 - OpenAPIToolkit to interact with APIs 
 - Create Pandas Dataframe Agent 
 - Create Python Agent  
- SQLDatabaseToolkit to manipulate databases and tables in SQL format 
- VectorStoreInfo class to store vectorized data  
- VectorStoreRouterToolkit to route requests between different vector stores   					    	     	      	       	        	          VectorStoreToolkit for interacting with the vector store.```
[0m
2023-04-29 20:49:53 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:49:53 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:49:53 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""SQL agent."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:51:00 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 20:51:00 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 20:51:00 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 20:51:00 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_600-620
Code:
                observation = InvalidTool().run(
                    agent_action.tool,
                    verbose=self.verbose,
                    color=None,
                    **tool_run_kwargs,
                )
            result.append((agent_action, observation))
        return result
    async def _atake_next_step(
        self,
        name_to_tool_map: Dict[str, BaseTool],
        color_mapping: Dict[str, str],
        inputs: Dict[str, str],
        intermediate_steps: List[Tuple[AgentAction, str]],
    ) -> Union[AgentFinish, List[Tuple[AgentAction, str]]]:
        """Take a single step in the thought-action-observation loop.
        Override this to take control of how the agent makes and acts on choices.
        """
        output = await self.agent.aplan(intermediate_steps, **inputs)
        if isinstance(output, AgentFinish):
Summary:
Contains the Agent class, which is used to create agents that can interact with a language chain environment
 - Includes methods for planning and taking actions in an environment
 - Defines the _atake_next_step method, which takes a single step in the thought-action-observation loop 
 - Implements logic for handling agent finishes ```
[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_600-620
Code:
                observation = InvalidTool().run(
                    agent_action.tool,
                    verbose=self.verbose,
                    color=None,
                    **tool_run_kwargs,
                )
            result.append((agent_action, observation))
        return result
    async def _atake_next_step(
        self,
        name_to_tool_map: Dict[str, BaseTool],
        color_mapping: Dict[str, str],
        inputs: Dict[str, str],
        intermediate_steps: List[Tuple[AgentAction, str]],
    ) -> Union[AgentFinish, List[Tuple[AgentAction, str]]]:
        """Take a single step in the thought-action-observation loop.
        Override this to take control of how the agent makes and acts on choices.
        """
        output = await self.agent.aplan(intermediate_steps, **inputs)
        if isinstance(output, AgentFinish):
Summary:
Contains the Agent class, which is used to create agents that can interact with a language chain environment
 - Includes methods for planning and taking actions in an environment
 - Defines the _atake_next_step method, which takes a single step in the thought-action-observation loop 
 - Implements logic for handling agent finishes ```
[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_220-240
Code:
        return list(set(self.llm_chain.input_keys) - {"intermediate_steps"})
    def plan(
        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any
    ) -> Union[AgentAction, AgentFinish]:
        """Given input, decided what to do.
        Args:
            intermediate_steps: Steps the LLM has taken to date,
                along with observations
            **kwargs: User inputs.
        Returns:
            Action specifying what tool to use.
        """
        output = self.llm_chain.run(
            intermediate_steps=intermediate_steps, stop=self.stop, **kwargs
        )
        return self.output_parser.parse(output)
    async def aplan(
        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any
    ) -> Union[AgentAction, AgentFinish]:
        """Given input, decided what to do.
Summary:
Contains the Agent class, which is used to define an agent's behavior
 - Defines methods for planning and running a language chain
 - Includes input_keys and output_parser attributes 
 - Has plan() and aplan() methods that take in intermediate steps as arguments 
```
[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_220-240
Code:
        return list(set(self.llm_chain.input_keys) - {"intermediate_steps"})
    def plan(
        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any
    ) -> Union[AgentAction, AgentFinish]:
        """Given input, decided what to do.
        Args:
            intermediate_steps: Steps the LLM has taken to date,
                along with observations
            **kwargs: User inputs.
        Returns:
            Action specifying what tool to use.
        """
        output = self.llm_chain.run(
            intermediate_steps=intermediate_steps, stop=self.stop, **kwargs
        )
        return self.output_parser.parse(output)
    async def aplan(
        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any
    ) -> Union[AgentAction, AgentFinish]:
        """Given input, decided what to do.
Summary:
Contains the Agent class, which is used to define an agent's behavior
 - Defines methods for planning and running a language chain
 - Includes input_keys and output_parser attributes 
 - Has plan() and aplan() methods that take in intermediate steps as arguments 
```
[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_560-580
Code:
            final_output["intermediate_steps"] = intermediate_steps
        return final_output
    def _take_next_step(
        self,
        name_to_tool_map: Dict[str, BaseTool],
        color_mapping: Dict[str, str],
        inputs: Dict[str, str],
        intermediate_steps: List[Tuple[AgentAction, str]],
    ) -> Union[AgentFinish, List[Tuple[AgentAction, str]]]:
        """Take a single step in the thought-action-observation loop.
        Override this to take control of how the agent makes and acts on choices.
        """
        output = self.agent.plan(intermediate_steps, **inputs)
        if isinstance(output, AgentFinish):
            return output
        actions: List[AgentAction]
        if isinstance(output, AgentAction):
            actions = [output]
        else:
            actions = output
Summary:
Contains the Agent class, which is used to plan and execute actions
 - Defines methods for taking a single step in the thought-action-observation loop
 - Includes functions for mapping names to tools, color mappings, and inputs 
 - Has an output function that returns either an AgentFinish or a list of tuples containing AgentAction and strings ```
[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_560-580
Code:
            final_output["intermediate_steps"] = intermediate_steps
        return final_output
    def _take_next_step(
        self,
        name_to_tool_map: Dict[str, BaseTool],
        color_mapping: Dict[str, str],
        inputs: Dict[str, str],
        intermediate_steps: List[Tuple[AgentAction, str]],
    ) -> Union[AgentFinish, List[Tuple[AgentAction, str]]]:
        """Take a single step in the thought-action-observation loop.
        Override this to take control of how the agent makes and acts on choices.
        """
        output = self.agent.plan(intermediate_steps, **inputs)
        if isinstance(output, AgentFinish):
            return output
        actions: List[AgentAction]
        if isinstance(output, AgentAction):
            actions = [output]
        else:
            actions = output
Summary:
Contains the Agent class, which is used to plan and execute actions
 - Defines methods for taking a single step in the thought-action-observation loop
 - Includes functions for mapping names to tools, color mappings, and inputs 
 - Has an output function that returns either an AgentFinish or a list of tuples containing AgentAction and strings ```
[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_320-340
Code:
                along with observations
            **kwargs: User inputs.
        Returns:
            Action specifying what tool to use.
        """
        full_inputs = self.get_full_inputs(intermediate_steps, **kwargs)
        action = self._get_next_action(full_inputs)
        if action.tool == self.finish_tool_name:
            return AgentFinish({"output": action.tool_input}, action.log)
        return action
    async def aplan(
        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any
    ) -> Union[AgentAction, AgentFinish]:
        """Given input, decided what to do.
        Args:
            intermediate_steps: Steps the LLM has taken to date,
                along with observations
            **kwargs: User inputs.
        Returns:
            Action specifying what tool to use.
Summary:
Contains the Agent class, which is responsible for managing and executing tasks
 - Includes methods to get full inputs, get next action, plan actions and execute actions
 - Has a finish tool name attribute that specifies when an agent has finished its task 
```
[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_320-340
Code:
                along with observations
            **kwargs: User inputs.
        Returns:
            Action specifying what tool to use.
        """
        full_inputs = self.get_full_inputs(intermediate_steps, **kwargs)
        action = self._get_next_action(full_inputs)
        if action.tool == self.finish_tool_name:
            return AgentFinish({"output": action.tool_input}, action.log)
        return action
    async def aplan(
        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any
    ) -> Union[AgentAction, AgentFinish]:
        """Given input, decided what to do.
        Args:
            intermediate_steps: Steps the LLM has taken to date,
                along with observations
            **kwargs: User inputs.
        Returns:
            Action specifying what tool to use.
Summary:
Contains the Agent class, which is responsible for managing and executing tasks
 - Includes methods to get full inputs, get next action, plan actions and execute actions
 - Has a finish tool name attribute that specifies when an agent has finished its task 
```
[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:agent_types.py
Code:
from enum import Enum


class AgentType(str, Enum):
    ZERO_SHOT_REACT_DESCRIPTION = "zero-shot-react-description"
    REACT_DOCSTORE = "react-docstore"
    SELF_ASK_WITH_SEARCH = "self-ask-with-search"
    CONVERSATIONAL_REACT_DESCRIPTION = "conversational-react-description"
    CHAT_ZERO_SHOT_REACT_DESCRIPTION = "chat-zero-shot-react-description"
    CHAT_CONVERSATIONAL_REACT_DESCRIPTION = "chat-conversational-react-description"
    CHAT_ZERO_SHOT_REACT_DESCRIPTION_V2 = "chat-zero-shot-react-description-002"

Summary:
Defines an Enum class called AgentType
 - Contains 6 different types of agents: 
    - Zero-Shot React Description 
    - React Docstore 
    - Self Ask with Search 
    - Conversational React Description 
    - Chat Zero Shot React Description  
    - Chat Conversational React Description  
```
[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:agent_types.py
Code:
from enum import Enum


class AgentType(str, Enum):
    ZERO_SHOT_REACT_DESCRIPTION = "zero-shot-react-description"
    REACT_DOCSTORE = "react-docstore"
    SELF_ASK_WITH_SEARCH = "self-ask-with-search"
    CONVERSATIONAL_REACT_DESCRIPTION = "conversational-react-description"
    CHAT_ZERO_SHOT_REACT_DESCRIPTION = "chat-zero-shot-react-description"
    CHAT_CONVERSATIONAL_REACT_DESCRIPTION = "chat-conversational-react-description"
    CHAT_ZERO_SHOT_REACT_DESCRIPTION_V2 = "chat-zero-shot-react-description-002"

Summary:
Defines an Enum class called AgentType
 - Contains 6 different types of agents: 
    - Zero-Shot React Description 
    - React Docstore 
    - Self Ask with Search 
    - Conversational React Description 
    - Chat Zero Shot React Description  
    - Chat Conversational React Description  
```
[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:loading.py_chunk_0-20
Code:
"""Functionality for loading agents."""
import json
from pathlib import Path
from typing import Any, List, Optional, Union
import yaml
from langchain.agents.agent import BaseSingleActionAgent
from langchain.agents.agent_types import AgentType
from langchain.agents.chat.base import ChatAgent
from langchain.agents.chat_v2.base import ChatAgentV2
from langchain.agents.conversational.base import ConversationalAgent
from langchain.agents.conversational_chat.base import ConversationalChatAgent
from langchain.agents.mrkl.base import ZeroShotAgent
from langchain.agents.react.base import ReActDocstoreAgent
from langchain.agents.self_ask_with_search.base import SelfAskWithSearchAgent
from langchain.agents.tools import Tool
from langchain.chains.loading import load_chain, load_chain_from_config
from langchain.llms.base import BaseLLM
from langchain.utilities.loading import try_load_from_hub
AGENT_TO_CLASS = {
    AgentType.ZERO_SHOT_REACT_DESCRIPTION: ZeroShotAgent,
Summary:
Imports json, pathlib, typing, yaml and other modules
 - Contains functions for loading agents from different types (AgentType) 
 - Includes a dictionary mapping AgentTypes to their corresponding classes 
 - Has functions for loading chains and configs from the project directory 
 - Utilizes try_load_from_hub() function to load data from hub ```
[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:loading.py_chunk_0-20
Code:
"""Functionality for loading agents."""
import json
from pathlib import Path
from typing import Any, List, Optional, Union
import yaml
from langchain.agents.agent import BaseSingleActionAgent
from langchain.agents.agent_types import AgentType
from langchain.agents.chat.base import ChatAgent
from langchain.agents.chat_v2.base import ChatAgentV2
from langchain.agents.conversational.base import ConversationalAgent
from langchain.agents.conversational_chat.base import ConversationalChatAgent
from langchain.agents.mrkl.base import ZeroShotAgent
from langchain.agents.react.base import ReActDocstoreAgent
from langchain.agents.self_ask_with_search.base import SelfAskWithSearchAgent
from langchain.agents.tools import Tool
from langchain.chains.loading import load_chain, load_chain_from_config
from langchain.llms.base import BaseLLM
from langchain.utilities.loading import try_load_from_hub
AGENT_TO_CLASS = {
    AgentType.ZERO_SHOT_REACT_DESCRIPTION: ZeroShotAgent,
Summary:
Imports json, pathlib, typing, yaml and other modules
 - Contains functions for loading agents from different types (AgentType) 
 - Includes a dictionary mapping AgentTypes to their corresponding classes 
 - Has functions for loading chains and configs from the project directory 
 - Utilizes try_load_from_hub() function to load data from hub ```
[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:planner_prompt.py_chunk_60-80
Code:
Begin!
Plan: {input}
Thought:
{agent_scratchpad}
"""
API_CONTROLLER_TOOL_NAME = "api_controller"
API_CONTROLLER_TOOL_DESCRIPTION = f"Can be used to execute a plan of API calls, like {API_CONTROLLER_TOOL_NAME}(plan)."
API_ORCHESTRATOR_PROMPT = """You are an agent that assists with user queries against API, things like querying information or creating resources.
Some user queries can be resolved in a single API call, particularly if you can find appropriate params from the OpenAPI spec; though some require several API call.
You should always plan your API calls first, and then execute the plan second.
If the plan includes a DELETE call, be sure to ask the User for authorization first unless the User has specifically asked to delete something.
You should never return information without executing the api_controller tool.
Here are the tools to plan and execute API requests: {tool_descriptions}
Starting below, you should follow this format:
User query: the query a User wants help with related to the API
Thought: you should always think about what to do
Action: the action to take, should be one of the tools [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Summary:
A Python file that contains a prompt for the user to plan their API calls
 - Includes tools to help with planning and executing API requests
 - Contains descriptions of each tool, as well as instructions on how to use them 
```
[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:planner_prompt.py_chunk_60-80
Code:
Begin!
Plan: {input}
Thought:
{agent_scratchpad}
"""
API_CONTROLLER_TOOL_NAME = "api_controller"
API_CONTROLLER_TOOL_DESCRIPTION = f"Can be used to execute a plan of API calls, like {API_CONTROLLER_TOOL_NAME}(plan)."
API_ORCHESTRATOR_PROMPT = """You are an agent that assists with user queries against API, things like querying information or creating resources.
Some user queries can be resolved in a single API call, particularly if you can find appropriate params from the OpenAPI spec; though some require several API call.
You should always plan your API calls first, and then execute the plan second.
If the plan includes a DELETE call, be sure to ask the User for authorization first unless the User has specifically asked to delete something.
You should never return information without executing the api_controller tool.
Here are the tools to plan and execute API requests: {tool_descriptions}
Starting below, you should follow this format:
User query: the query a User wants help with related to the API
Thought: you should always think about what to do
Action: the action to take, should be one of the tools [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Summary:
A Python file that contains a prompt for the user to plan their API calls
 - Includes tools to help with planning and executing API requests
 - Contains descriptions of each tool, as well as instructions on how to use them 
```
[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:__init__.py_chunk_0-20
Code:
"""Agent toolkits."""
from langchain.agents.agent_toolkits.csv.base import create_csv_agent
from langchain.agents.agent_toolkits.json.base import create_json_agent
from langchain.agents.agent_toolkits.json.toolkit import JsonToolkit
from langchain.agents.agent_toolkits.nla.toolkit import NLAToolkit
from langchain.agents.agent_toolkits.openapi.base import create_openapi_agent
from langchain.agents.agent_toolkits.openapi.toolkit import OpenAPIToolkit
from langchain.agents.agent_toolkits.pandas.base import create_pandas_dataframe_agent
from langchain.agents.agent_toolkits.python.base import create_python_agent
from langchain.agents.agent_toolkits.sql.base import create_sql_agent
from langchain.agents.agent_toolkits.sql.toolkit import SQLDatabaseToolkit
from langchain.agents.agent_toolkits.vectorstore.base import (
    create_vectorstore_agent,
    create_vectorstore_router_agent,
)
from langchain.agents.agent_toolkits.vectorstore.toolkit import (
    VectorStoreInfo,
    VectorStoreRouterToolkit,
    VectorStoreToolkit,
)
Summary:
Create CSV Agent
 - Create JSON Agent
 - JsonToolkit for manipulating JSON data
 - NLAToolkit for Natural Language Processing tasks 
 - Create OpenAPI Agent 
 - OpenAPIToolkit to interact with APIs 
 - Create Pandas Dataframe Agent 
 - Create Python Agent  
- SQLDatabaseToolkit to manipulate databases and tables in SQL format 
- VectorStoreInfo class to store vectorized data  
- VectorStoreRouterToolkit to route requests between different vector stores   					    	     	      	       	        	          VectorStoreToolkit for interacting with the vector store.```
[0m
2023-04-29 20:51:01 - PARSERO - [32m[47mINFO[0m - File:__init__.py_chunk_0-20
Code:
"""Agent toolkits."""
from langchain.agents.agent_toolkits.csv.base import create_csv_agent
from langchain.agents.agent_toolkits.json.base import create_json_agent
from langchain.agents.agent_toolkits.json.toolkit import JsonToolkit
from langchain.agents.agent_toolkits.nla.toolkit import NLAToolkit
from langchain.agents.agent_toolkits.openapi.base import create_openapi_agent
from langchain.agents.agent_toolkits.openapi.toolkit import OpenAPIToolkit
from langchain.agents.agent_toolkits.pandas.base import create_pandas_dataframe_agent
from langchain.agents.agent_toolkits.python.base import create_python_agent
from langchain.agents.agent_toolkits.sql.base import create_sql_agent
from langchain.agents.agent_toolkits.sql.toolkit import SQLDatabaseToolkit
from langchain.agents.agent_toolkits.vectorstore.base import (
    create_vectorstore_agent,
    create_vectorstore_router_agent,
)
from langchain.agents.agent_toolkits.vectorstore.toolkit import (
    VectorStoreInfo,
    VectorStoreRouterToolkit,
    VectorStoreToolkit,
)
Summary:
Create CSV Agent
 - Create JSON Agent
 - JsonToolkit for manipulating JSON data
 - NLAToolkit for Natural Language Processing tasks 
 - Create OpenAPI Agent 
 - OpenAPIToolkit to interact with APIs 
 - Create Pandas Dataframe Agent 
 - Create Python Agent  
- SQLDatabaseToolkit to manipulate databases and tables in SQL format 
- VectorStoreInfo class to store vectorized data  
- VectorStoreRouterToolkit to route requests between different vector stores   					    	     	      	       	        	          VectorStoreToolkit for interacting with the vector store.```
[0m
2023-04-29 20:51:48 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 20:51:48 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 20:51:48 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_120-140
Code:
        """Construct an agent from an LLM and tools."""
        cls._validate_tools(tools)
        _output_parser = output_parser or AgentOutputParser()
        prompt = cls.create_prompt(
            tools,
            system_message=system_message,
            human_message=human_message,
            input_variables=input_variables,
            output_parser=_output_parser,
        )
        llm_chain = LLMChain(
            llm=llm,
            prompt=prompt,
            callback_manager=callback_manager,
        )
        tool_names = [tool.name for tool in tools]
        return cls(
            llm_chain=llm_chain,
            allowed_tools=tool_names,
            output_parser=_output_parser,
Summary:
Contains the base class for ReAct agents
 - Defines methods to handle user input and generate responses
 - Includes a method to parse natural language queries into structured data 
 - Implements an interface for interacting with external services such as docstores ```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_120-140
Code:
        """Construct an agent from an LLM and tools."""
        cls._validate_tools(tools)
        _output_parser = output_parser or AgentOutputParser()
        prompt = cls.create_prompt(
            tools,
            system_message=system_message,
            human_message=human_message,
            input_variables=input_variables,
            output_parser=_output_parser,
        )
        llm_chain = LLMChain(
            llm=llm,
            prompt=prompt,
            callback_manager=callback_manager,
        )
        tool_names = [tool.name for tool in tools]
        return cls(
            llm_chain=llm_chain,
            allowed_tools=tool_names,
            output_parser=_output_parser,
Summary:
Contains the base class for ReAct agents
 - Defines methods to handle user input and generate responses
 - Includes a method to parse natural language queries into structured data 
 - Implements an interface for interacting with external services such as docstores ```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_120-140
Code:
        """Construct an agent from an LLM and tools."""
        cls._validate_tools(tools)
        _output_parser = output_parser or AgentOutputParser()
        prompt = cls.create_prompt(
            tools,
            system_message=system_message,
            human_message=human_message,
            input_variables=input_variables,
            output_parser=_output_parser,
        )
        llm_chain = LLMChain(
            llm=llm,
            prompt=prompt,
            callback_manager=callback_manager,
        )
        tool_names = [tool.name for tool in tools]
        return cls(
            llm_chain=llm_chain,
            allowed_tools=tool_names,
            output_parser=_output_parser,
Summary:
Contains the base class for ReAct agents
 - Defines methods to handle user input and generate responses
 - Includes a method to parse natural language queries into structured data 
 - Implements an interface for interacting with external services such as docstores ```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_120-140
Code:
    Example:
        .. code-block:: python
            from langchain import OpenAI, MRKLChain
            from langchain.chains.mrkl.base import ChainConfig
            llm = OpenAI(temperature=0)
            prompt = PromptTemplate(...)
            chains = [...]
            mrkl = MRKLChain.from_chains(llm=llm, prompt=prompt)
    """
    @classmethod
    def from_chains(
        cls, llm: BaseLanguageModel, chains: List[ChainConfig], **kwargs: Any
    ) -> AgentExecutor:
        """User friendly way to initialize the MRKL chain.
        This is intended to be an easy way to get up and running with the
        MRKL chain.
        Args:
            llm: The LLM to use as the agent LLM.
            chains: The chains the MRKL system has access to.
            **kwargs: parameters to be passed to initialization.
Summary:
Contains the base class for ReAct agents
 - Defines methods to handle user input and generate responses
 - Includes a method to parse natural language queries into structured data 
 - Implements an interface for interacting with external services such as docstores ```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_120-140
Code:
    Example:
        .. code-block:: python
            from langchain import OpenAI, MRKLChain
            from langchain.chains.mrkl.base import ChainConfig
            llm = OpenAI(temperature=0)
            prompt = PromptTemplate(...)
            chains = [...]
            mrkl = MRKLChain.from_chains(llm=llm, prompt=prompt)
    """
    @classmethod
    def from_chains(
        cls, llm: BaseLanguageModel, chains: List[ChainConfig], **kwargs: Any
    ) -> AgentExecutor:
        """User friendly way to initialize the MRKL chain.
        This is intended to be an easy way to get up and running with the
        MRKL chain.
        Args:
            llm: The LLM to use as the agent LLM.
            chains: The chains the MRKL system has access to.
            **kwargs: parameters to be passed to initialization.
Summary:
Contains the base class for ReAct agents
 - Defines methods to handle user input and generate responses
 - Includes a method to parse natural language queries into structured data 
 - Implements an interface for interacting with external services such as docstores ```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_120-140
Code:
    Example:
        .. code-block:: python
            from langchain import OpenAI, MRKLChain
            from langchain.chains.mrkl.base import ChainConfig
            llm = OpenAI(temperature=0)
            prompt = PromptTemplate(...)
            chains = [...]
            mrkl = MRKLChain.from_chains(llm=llm, prompt=prompt)
    """
    @classmethod
    def from_chains(
        cls, llm: BaseLanguageModel, chains: List[ChainConfig], **kwargs: Any
    ) -> AgentExecutor:
        """User friendly way to initialize the MRKL chain.
        This is intended to be an easy way to get up and running with the
        MRKL chain.
        Args:
            llm: The LLM to use as the agent LLM.
            chains: The chains the MRKL system has access to.
            **kwargs: parameters to be passed to initialization.
Summary:
Contains the base class for ReAct agents
 - Defines methods to handle user input and generate responses
 - Includes a method to parse natural language queries into structured data 
 - Implements an interface for interacting with external services such as docstores ```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_120-140
Code:
    """
    def __init__(self, llm: BaseLLM, docstore: Docstore, **kwargs: Any):
        """Initialize with the LLM and a docstore."""
        docstore_explorer = DocstoreExplorer(docstore)
        tools = [
            Tool(
                name="Search",
                func=docstore_explorer.search,
                description="Search for a term in the docstore.",
            ),
            Tool(
                name="Lookup",
                func=docstore_explorer.lookup,
                description="Lookup a term in the docstore.",
            ),
        ]
        agent = ReActDocstoreAgent.from_llm_and_tools(llm, tools)
        super().__init__(agent=agent, tools=tools, **kwargs)
Summary:
Contains the base class for ReAct agents
 - Defines methods to handle user input and generate responses
 - Includes a method to parse natural language queries into structured data 
 - Implements an interface for interacting with external services such as docstores ```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_120-140
Code:
    """
    def __init__(self, llm: BaseLLM, docstore: Docstore, **kwargs: Any):
        """Initialize with the LLM and a docstore."""
        docstore_explorer = DocstoreExplorer(docstore)
        tools = [
            Tool(
                name="Search",
                func=docstore_explorer.search,
                description="Search for a term in the docstore.",
            ),
            Tool(
                name="Lookup",
                func=docstore_explorer.lookup,
                description="Lookup a term in the docstore.",
            ),
        ]
        agent = ReActDocstoreAgent.from_llm_and_tools(llm, tools)
        super().__init__(agent=agent, tools=tools, **kwargs)
Summary:
Contains the base class for ReAct agents
 - Defines methods to handle user input and generate responses
 - Includes a method to parse natural language queries into structured data 
 - Implements an interface for interacting with external services such as docstores ```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_120-140
Code:
    """
    def __init__(self, llm: BaseLLM, docstore: Docstore, **kwargs: Any):
        """Initialize with the LLM and a docstore."""
        docstore_explorer = DocstoreExplorer(docstore)
        tools = [
            Tool(
                name="Search",
                func=docstore_explorer.search,
                description="Search for a term in the docstore.",
            ),
            Tool(
                name="Lookup",
                func=docstore_explorer.lookup,
                description="Lookup a term in the docstore.",
            ),
        ]
        agent = ReActDocstoreAgent.from_llm_and_tools(llm, tools)
        super().__init__(agent=agent, tools=tools, **kwargs)
Summary:
Contains the base class for ReAct agents
 - Defines methods to handle user input and generate responses
 - Includes a method to parse natural language queries into structured data 
 - Implements an interface for interacting with external services such as docstores ```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0-20
Code:
"""Json agent."""
from typing import Any, List, Optional
from langchain.agents.agent import AgentExecutor
from langchain.agents.agent_toolkits.json.prompt import JSON_PREFIX, JSON_SUFFIX
from langchain.agents.agent_toolkits.json.toolkit import JsonToolkit
from langchain.agents.mrkl.base import ZeroShotAgent
from langchain.agents.mrkl.prompt import FORMAT_INSTRUCTIONS
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains.llm import LLMChain
from langchain.llms.base import BaseLLM
def create_json_agent(
    llm: BaseLLM,
    toolkit: JsonToolkit,
    callback_manager: Optional[BaseCallbackManager] = None,
    prefix: str = JSON_PREFIX,
    suffix: str = JSON_SUFFIX,
    format_instructions: str = FORMAT_INSTRUCTIONS,
    input_variables: Optional[List[str]] = None,
    verbose: bool = False,
    **kwargs: Any,
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class called ReActDocstoreAgent which is an Agent for the ReAct chain
 - Includes properties such as _agent_type and _executor 
 - Has methods such as __init__, execute, and get_prompts 
 - Uses tools like Tool, BaseTool, Docstore, Document etc to optimize codebase```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0-20
Code:
"""Json agent."""
from typing import Any, List, Optional
from langchain.agents.agent import AgentExecutor
from langchain.agents.agent_toolkits.json.prompt import JSON_PREFIX, JSON_SUFFIX
from langchain.agents.agent_toolkits.json.toolkit import JsonToolkit
from langchain.agents.mrkl.base import ZeroShotAgent
from langchain.agents.mrkl.prompt import FORMAT_INSTRUCTIONS
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains.llm import LLMChain
from langchain.llms.base import BaseLLM
def create_json_agent(
    llm: BaseLLM,
    toolkit: JsonToolkit,
    callback_manager: Optional[BaseCallbackManager] = None,
    prefix: str = JSON_PREFIX,
    suffix: str = JSON_SUFFIX,
    format_instructions: str = FORMAT_INSTRUCTIONS,
    input_variables: Optional[List[str]] = None,
    verbose: bool = False,
    **kwargs: Any,
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class called ReActDocstoreAgent which is an Agent for the ReAct chain
 - Includes properties such as _agent_type and _executor 
 - Has methods such as __init__, execute, and get_prompts 
 - Uses tools like Tool, BaseTool, Docstore, Document etc to optimize codebase```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0-20
Code:
"""Json agent."""
from typing import Any, List, Optional
from langchain.agents.agent import AgentExecutor
from langchain.agents.agent_toolkits.json.prompt import JSON_PREFIX, JSON_SUFFIX
from langchain.agents.agent_toolkits.json.toolkit import JsonToolkit
from langchain.agents.mrkl.base import ZeroShotAgent
from langchain.agents.mrkl.prompt import FORMAT_INSTRUCTIONS
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains.llm import LLMChain
from langchain.llms.base import BaseLLM
def create_json_agent(
    llm: BaseLLM,
    toolkit: JsonToolkit,
    callback_manager: Optional[BaseCallbackManager] = None,
    prefix: str = JSON_PREFIX,
    suffix: str = JSON_SUFFIX,
    format_instructions: str = FORMAT_INSTRUCTIONS,
    input_variables: Optional[List[str]] = None,
    verbose: bool = False,
    **kwargs: Any,
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class called ReActDocstoreAgent which is an Agent for the ReAct chain
 - Includes properties such as _agent_type and _executor 
 - Has methods such as __init__, execute, and get_prompts 
 - Uses tools like Tool, BaseTool, Docstore, Document etc to optimize codebase```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0-20
Code:
"""SQL agent."""
from typing import Any, List, Optional
from langchain.agents.agent import AgentExecutor
from langchain.agents.agent_toolkits.sql.prompt import SQL_PREFIX, SQL_SUFFIX
from langchain.agents.agent_toolkits.sql.toolkit import SQLDatabaseToolkit
from langchain.agents.mrkl.base import ZeroShotAgent
from langchain.agents.mrkl.prompt import FORMAT_INSTRUCTIONS
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains.llm import LLMChain
from langchain.llms.base import BaseLLM
def create_sql_agent(
    llm: BaseLLM,
    toolkit: SQLDatabaseToolkit,
    callback_manager: Optional[BaseCallbackManager] = None,
    prefix: str = SQL_PREFIX,
    suffix: str = SQL_SUFFIX,
    format_instructions: str = FORMAT_INSTRUCTIONS,
    input_variables: Optional[List[str]] = None,
    top_k: int = 10,
    max_iterations: Optional[int] = 15,
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class called ReActDocstoreAgent which is an Agent for the ReAct chain
 - Includes properties such as _agent_type and _executor 
 - Has methods such as __init__, execute, and get_prompts 
 - Uses tools like Tool, BaseTool, Docstore, Document etc to optimize codebase```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0-20
Code:
"""SQL agent."""
from typing import Any, List, Optional
from langchain.agents.agent import AgentExecutor
from langchain.agents.agent_toolkits.sql.prompt import SQL_PREFIX, SQL_SUFFIX
from langchain.agents.agent_toolkits.sql.toolkit import SQLDatabaseToolkit
from langchain.agents.mrkl.base import ZeroShotAgent
from langchain.agents.mrkl.prompt import FORMAT_INSTRUCTIONS
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains.llm import LLMChain
from langchain.llms.base import BaseLLM
def create_sql_agent(
    llm: BaseLLM,
    toolkit: SQLDatabaseToolkit,
    callback_manager: Optional[BaseCallbackManager] = None,
    prefix: str = SQL_PREFIX,
    suffix: str = SQL_SUFFIX,
    format_instructions: str = FORMAT_INSTRUCTIONS,
    input_variables: Optional[List[str]] = None,
    top_k: int = 10,
    max_iterations: Optional[int] = 15,
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class called ReActDocstoreAgent which is an Agent for the ReAct chain
 - Includes properties such as _agent_type and _executor 
 - Has methods such as __init__, execute, and get_prompts 
 - Uses tools like Tool, BaseTool, Docstore, Document etc to optimize codebase```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0-20
Code:
"""SQL agent."""
from typing import Any, List, Optional
from langchain.agents.agent import AgentExecutor
from langchain.agents.agent_toolkits.sql.prompt import SQL_PREFIX, SQL_SUFFIX
from langchain.agents.agent_toolkits.sql.toolkit import SQLDatabaseToolkit
from langchain.agents.mrkl.base import ZeroShotAgent
from langchain.agents.mrkl.prompt import FORMAT_INSTRUCTIONS
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains.llm import LLMChain
from langchain.llms.base import BaseLLM
def create_sql_agent(
    llm: BaseLLM,
    toolkit: SQLDatabaseToolkit,
    callback_manager: Optional[BaseCallbackManager] = None,
    prefix: str = SQL_PREFIX,
    suffix: str = SQL_SUFFIX,
    format_instructions: str = FORMAT_INSTRUCTIONS,
    input_variables: Optional[List[str]] = None,
    top_k: int = 10,
    max_iterations: Optional[int] = 15,
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class called ReActDocstoreAgent which is an Agent for the ReAct chain
 - Includes properties such as _agent_type and _executor 
 - Has methods such as __init__, execute, and get_prompts 
 - Uses tools like Tool, BaseTool, Docstore, Document etc to optimize codebase```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0-20
Code:
"""Chain that implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf."""
import re
from typing import Any, List, Optional, Sequence, Tuple
from langchain.agents.agent import Agent, AgentExecutor
from langchain.agents.agent_types import AgentType
from langchain.agents.react.textworld_prompt import TEXTWORLD_PROMPT
from langchain.agents.react.wiki_prompt import WIKI_PROMPT
from langchain.agents.tools import Tool
from langchain.docstore.base import Docstore
from langchain.docstore.document import Document
from langchain.llms.base import BaseLLM
from langchain.prompts.base import BasePromptTemplate
from langchain.tools.base import BaseTool
class ReActDocstoreAgent(Agent):
    """Agent for the ReAct chain."""
    @property
    def _agent_type(self) -> str:
        """Return Identifier of agent type."""
        return AgentType.REACT_DOCSTORE
    @classmethod
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class called ReActDocstoreAgent which is an Agent for the ReAct chain
 - Includes properties such as _agent_type and _executor 
 - Has methods such as __init__, execute, and get_prompts 
 - Uses tools like Tool, BaseTool, Docstore, Document etc to optimize codebase```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0-20
Code:
"""Chain that implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf."""
import re
from typing import Any, List, Optional, Sequence, Tuple
from langchain.agents.agent import Agent, AgentExecutor
from langchain.agents.agent_types import AgentType
from langchain.agents.react.textworld_prompt import TEXTWORLD_PROMPT
from langchain.agents.react.wiki_prompt import WIKI_PROMPT
from langchain.agents.tools import Tool
from langchain.docstore.base import Docstore
from langchain.docstore.document import Document
from langchain.llms.base import BaseLLM
from langchain.prompts.base import BasePromptTemplate
from langchain.tools.base import BaseTool
class ReActDocstoreAgent(Agent):
    """Agent for the ReAct chain."""
    @property
    def _agent_type(self) -> str:
        """Return Identifier of agent type."""
        return AgentType.REACT_DOCSTORE
    @classmethod
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class called ReActDocstoreAgent which is an Agent for the ReAct chain
 - Includes properties such as _agent_type and _executor 
 - Has methods such as __init__, execute, and get_prompts 
 - Uses tools like Tool, BaseTool, Docstore, Document etc to optimize codebase```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0-20
Code:
"""Chain that implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf."""
import re
from typing import Any, List, Optional, Sequence, Tuple
from langchain.agents.agent import Agent, AgentExecutor
from langchain.agents.agent_types import AgentType
from langchain.agents.react.textworld_prompt import TEXTWORLD_PROMPT
from langchain.agents.react.wiki_prompt import WIKI_PROMPT
from langchain.agents.tools import Tool
from langchain.docstore.base import Docstore
from langchain.docstore.document import Document
from langchain.llms.base import BaseLLM
from langchain.prompts.base import BasePromptTemplate
from langchain.tools.base import BaseTool
class ReActDocstoreAgent(Agent):
    """Agent for the ReAct chain."""
    @property
    def _agent_type(self) -> str:
        """Return Identifier of agent type."""
        return AgentType.REACT_DOCSTORE
    @classmethod
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class called ReActDocstoreAgent which is an Agent for the ReAct chain
 - Includes properties such as _agent_type and _executor 
 - Has methods such as __init__, execute, and get_prompts 
 - Uses tools like Tool, BaseTool, Docstore, Document etc to optimize codebase```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_100-120
Code:
        return self.document.page_content.split("\n\n")
class ReActTextWorldAgent(ReActDocstoreAgent):
    """Agent for the ReAct TextWorld chain."""
    @classmethod
    def create_prompt(cls, tools: Sequence[BaseTool]) -> BasePromptTemplate:
        """Return default prompt."""
        return TEXTWORLD_PROMPT
    @classmethod
    def _validate_tools(cls, tools: Sequence[BaseTool]) -> None:
        if len(tools) != 1:
            raise ValueError(f"Exactly one tool must be specified, but got {tools}")
        tool_names = {tool.name for tool in tools}
        if tool_names != {"Play"}:
            raise ValueError(f"Tool name should be Play, got {tool_names}")
class ReActChain(AgentExecutor):
    """Chain that implements the ReAct paper.
    Example:
        .. code-block:: python
            from langchain import ReActChain, OpenAI
            react = ReAct(llm=OpenAI())
Summary:
Contains the ReActTextWorldAgent class, which is used to create a prompt for TextWorld
 - Includes the _validate_tools method, which checks that only one tool (Play) is specified
 - Defines the ReActChain class, which implements the ReAct paper  ```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_100-120
Code:
        return self.document.page_content.split("\n\n")
class ReActTextWorldAgent(ReActDocstoreAgent):
    """Agent for the ReAct TextWorld chain."""
    @classmethod
    def create_prompt(cls, tools: Sequence[BaseTool]) -> BasePromptTemplate:
        """Return default prompt."""
        return TEXTWORLD_PROMPT
    @classmethod
    def _validate_tools(cls, tools: Sequence[BaseTool]) -> None:
        if len(tools) != 1:
            raise ValueError(f"Exactly one tool must be specified, but got {tools}")
        tool_names = {tool.name for tool in tools}
        if tool_names != {"Play"}:
            raise ValueError(f"Tool name should be Play, got {tool_names}")
class ReActChain(AgentExecutor):
    """Chain that implements the ReAct paper.
    Example:
        .. code-block:: python
            from langchain import ReActChain, OpenAI
            react = ReAct(llm=OpenAI())
Summary:
Contains the ReActTextWorldAgent class, which is used to create a prompt for TextWorld
 - Includes the _validate_tools method, which checks that only one tool (Play) is specified
 - Defines the ReActChain class, which implements the ReAct paper  ```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_100-120
Code:
        return self.document.page_content.split("\n\n")
class ReActTextWorldAgent(ReActDocstoreAgent):
    """Agent for the ReAct TextWorld chain."""
    @classmethod
    def create_prompt(cls, tools: Sequence[BaseTool]) -> BasePromptTemplate:
        """Return default prompt."""
        return TEXTWORLD_PROMPT
    @classmethod
    def _validate_tools(cls, tools: Sequence[BaseTool]) -> None:
        if len(tools) != 1:
            raise ValueError(f"Exactly one tool must be specified, but got {tools}")
        tool_names = {tool.name for tool in tools}
        if tool_names != {"Play"}:
            raise ValueError(f"Tool name should be Play, got {tool_names}")
class ReActChain(AgentExecutor):
    """Chain that implements the ReAct paper.
    Example:
        .. code-block:: python
            from langchain import ReActChain, OpenAI
            react = ReAct(llm=OpenAI())
Summary:
Contains the ReActTextWorldAgent class, which is used to create a prompt for TextWorld
 - Includes the _validate_tools method, which checks that only one tool (Play) is specified
 - Defines the ReActChain class, which implements the ReAct paper  ```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:agent_types.py
Code:
from enum import Enum


class AgentType(str, Enum):
    ZERO_SHOT_REACT_DESCRIPTION = "zero-shot-react-description"
    REACT_DOCSTORE = "react-docstore"
    SELF_ASK_WITH_SEARCH = "self-ask-with-search"
    CONVERSATIONAL_REACT_DESCRIPTION = "conversational-react-description"
    CHAT_ZERO_SHOT_REACT_DESCRIPTION = "chat-zero-shot-react-description"
    CHAT_CONVERSATIONAL_REACT_DESCRIPTION = "chat-conversational-react-description"
    CHAT_ZERO_SHOT_REACT_DESCRIPTION_V2 = "chat-zero-shot-react-description-002"

Summary:
Defines an Enum class called AgentType
 - Contains 6 different types of agents: 
    - Zero-Shot React Description 
    - React Docstore 
    - Self Ask with Search 
    - Conversational React Description 
    - Chat Zero Shot React Description  
    - Chat Conversational React Description  
```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:agent_types.py
Code:
from enum import Enum


class AgentType(str, Enum):
    ZERO_SHOT_REACT_DESCRIPTION = "zero-shot-react-description"
    REACT_DOCSTORE = "react-docstore"
    SELF_ASK_WITH_SEARCH = "self-ask-with-search"
    CONVERSATIONAL_REACT_DESCRIPTION = "conversational-react-description"
    CHAT_ZERO_SHOT_REACT_DESCRIPTION = "chat-zero-shot-react-description"
    CHAT_CONVERSATIONAL_REACT_DESCRIPTION = "chat-conversational-react-description"
    CHAT_ZERO_SHOT_REACT_DESCRIPTION_V2 = "chat-zero-shot-react-description-002"

Summary:
Defines an Enum class called AgentType
 - Contains 6 different types of agents: 
    - Zero-Shot React Description 
    - React Docstore 
    - Self Ask with Search 
    - Conversational React Description 
    - Chat Zero Shot React Description  
    - Chat Conversational React Description  
```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:agent_types.py
Code:
from enum import Enum


class AgentType(str, Enum):
    ZERO_SHOT_REACT_DESCRIPTION = "zero-shot-react-description"
    REACT_DOCSTORE = "react-docstore"
    SELF_ASK_WITH_SEARCH = "self-ask-with-search"
    CONVERSATIONAL_REACT_DESCRIPTION = "conversational-react-description"
    CHAT_ZERO_SHOT_REACT_DESCRIPTION = "chat-zero-shot-react-description"
    CHAT_CONVERSATIONAL_REACT_DESCRIPTION = "chat-conversational-react-description"
    CHAT_ZERO_SHOT_REACT_DESCRIPTION_V2 = "chat-zero-shot-react-description-002"

Summary:
Defines an Enum class called AgentType
 - Contains 6 different types of agents: 
    - Zero-Shot React Description 
    - React Docstore 
    - Self Ask with Search 
    - Conversational React Description 
    - Chat Zero Shot React Description  
    - Chat Conversational React Description  
```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:wiki_prompt.py_chunk_40-60
Code:
Action: Search[Elia Kazan]
Observation: Elia Kazan was an American film and theatre director, producer, screenwriter and actor.
Thought: Professions of Elia Kazan are director, producer, screenwriter, and actor. So profession Nicholas Ray and Elia Kazan have in common is director, screenwriter, and actor.
Action: Finish[director, screenwriter, actor]""",
    """Question: Which magazine was started first Arthurâ€™s Magazine or First for Women?
Thought: I need to search Arthurâ€™s Magazine and First for Women, and find which was started first.
Action: Search[Arthurâ€™s Magazine]
Observation: Arthurâ€™s Magazine (1844-1846) was an American literary periodical published in Philadelphia in the 19th century.
Thought: Arthurâ€™s Magazine was started in 1844. I need to search First for Women next.
Action: Search[First for Women]
Observation: First for Women is a womanâ€™s magazine published by Bauer Media Group in the USA.[1] The magazine was started in 1989.
Thought: First for Women was started in 1989. 1844 (Arthurâ€™s Magazine) < 1989 (First for Women), so Arthurâ€™s Magazine was started first.
Action: Finish[Arthurâ€™s Magazine]""",
    """Question: Were Pavel Urysohn and Leonid Levin known for the same type of work?
Thought: I need to search Pavel Urysohn and Leonid Levin, find their types of work, then find if they are the same.
Action: Search[Pavel Urysohn]
Observation: Pavel Samuilovich Urysohn (February 3, 1898 - August 17, 1924) was a Soviet mathematician who is best known for his contributions in dimension theory.
Thought: Pavel Urysohn is a mathematician. I need to search Leonid Levin next and find its type of work.
Action: Search[Leonid Levin]
Observation: Leonid Anatolievich Levin is a Soviet-American mathematician and computer scientist.
Summary:
The file contains a React agent for the WikiPrompt task
 - It implements an abstract class from the `agents/base_agent.py` file
 - It defines functions to interact with the environment, such as `act()`, `learn()`, and `reset_episode()` 
 - It also includes helper functions to process observations and rewards ```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:wiki_prompt.py_chunk_40-60
Code:
Action: Search[Elia Kazan]
Observation: Elia Kazan was an American film and theatre director, producer, screenwriter and actor.
Thought: Professions of Elia Kazan are director, producer, screenwriter, and actor. So profession Nicholas Ray and Elia Kazan have in common is director, screenwriter, and actor.
Action: Finish[director, screenwriter, actor]""",
    """Question: Which magazine was started first Arthurâ€™s Magazine or First for Women?
Thought: I need to search Arthurâ€™s Magazine and First for Women, and find which was started first.
Action: Search[Arthurâ€™s Magazine]
Observation: Arthurâ€™s Magazine (1844-1846) was an American literary periodical published in Philadelphia in the 19th century.
Thought: Arthurâ€™s Magazine was started in 1844. I need to search First for Women next.
Action: Search[First for Women]
Observation: First for Women is a womanâ€™s magazine published by Bauer Media Group in the USA.[1] The magazine was started in 1989.
Thought: First for Women was started in 1989. 1844 (Arthurâ€™s Magazine) < 1989 (First for Women), so Arthurâ€™s Magazine was started first.
Action: Finish[Arthurâ€™s Magazine]""",
    """Question: Were Pavel Urysohn and Leonid Levin known for the same type of work?
Thought: I need to search Pavel Urysohn and Leonid Levin, find their types of work, then find if they are the same.
Action: Search[Pavel Urysohn]
Observation: Pavel Samuilovich Urysohn (February 3, 1898 - August 17, 1924) was a Soviet mathematician who is best known for his contributions in dimension theory.
Thought: Pavel Urysohn is a mathematician. I need to search Leonid Levin next and find its type of work.
Action: Search[Leonid Levin]
Observation: Leonid Anatolievich Levin is a Soviet-American mathematician and computer scientist.
Summary:
The file contains a React agent for the WikiPrompt task
 - It implements an abstract class from the `agents/base_agent.py` file
 - It defines functions to interact with the environment, such as `act()`, `learn()`, and `reset_episode()` 
 - It also includes helper functions to process observations and rewards ```
[0m
2023-04-29 20:51:49 - PARSERO - [32m[47mINFO[0m - File:wiki_prompt.py_chunk_40-60
Code:
Action: Search[Elia Kazan]
Observation: Elia Kazan was an American film and theatre director, producer, screenwriter and actor.
Thought: Professions of Elia Kazan are director, producer, screenwriter, and actor. So profession Nicholas Ray and Elia Kazan have in common is director, screenwriter, and actor.
Action: Finish[director, screenwriter, actor]""",
    """Question: Which magazine was started first Arthurâ€™s Magazine or First for Women?
Thought: I need to search Arthurâ€™s Magazine and First for Women, and find which was started first.
Action: Search[Arthurâ€™s Magazine]
Observation: Arthurâ€™s Magazine (1844-1846) was an American literary periodical published in Philadelphia in the 19th century.
Thought: Arthurâ€™s Magazine was started in 1844. I need to search First for Women next.
Action: Search[First for Women]
Observation: First for Women is a womanâ€™s magazine published by Bauer Media Group in the USA.[1] The magazine was started in 1989.
Thought: First for Women was started in 1989. 1844 (Arthurâ€™s Magazine) < 1989 (First for Women), so Arthurâ€™s Magazine was started first.
Action: Finish[Arthurâ€™s Magazine]""",
    """Question: Were Pavel Urysohn and Leonid Levin known for the same type of work?
Thought: I need to search Pavel Urysohn and Leonid Levin, find their types of work, then find if they are the same.
Action: Search[Pavel Urysohn]
Observation: Pavel Samuilovich Urysohn (February 3, 1898 - August 17, 1924) was a Soviet mathematician who is best known for his contributions in dimension theory.
Thought: Pavel Urysohn is a mathematician. I need to search Leonid Levin next and find its type of work.
Action: Search[Leonid Levin]
Observation: Leonid Anatolievich Levin is a Soviet-American mathematician and computer scientist.
Summary:
The file contains a React agent for the WikiPrompt task
 - It implements an abstract class from the `agents/base_agent.py` file
 - It defines functions to interact with the environment, such as `act()`, `learn()`, and `reset_episode()` 
 - It also includes helper functions to process observations and rewards ```
[0m
2023-04-29 20:52:57 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 20:52:57 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 20:52:57 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 20:52:57 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 20:52:57 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 20:52:57 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 20:52:57 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 20:52:57 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_260-280
Code:
    intermediary work.
    """
    llm_chain: LLMChain
    allowed_tools: Optional[List[str]] = None
    def get_allowed_tools(self) -> Optional[List[str]]:
        return self.allowed_tools
    @property
    def return_values(self) -> List[str]:
        return ["output"]
    @abstractmethod
    def _extract_tool_and_input(self, text: str) -> Optional[Tuple[str, str]]:
        """Extract tool and tool input from llm output."""
    def _fix_text(self, text: str) -> str:
        """Fix the text."""
        raise ValueError("fix_text not implemented for this agent.")
    @property
    def _stop(self) -> List[str]:
        return [
            f"\n{self.observation_prefix.rstrip()}",
            f"\n\t{self.observation_prefix.rstrip()}",
Summary:
Agent class is the base class for all agents
 - It provides methods to extract tool and input from LLM output, as well as a method to fix text
 - It also contains properties such as return values and stop words 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_260-280
Code:
    intermediary work.
    """
    llm_chain: LLMChain
    allowed_tools: Optional[List[str]] = None
    def get_allowed_tools(self) -> Optional[List[str]]:
        return self.allowed_tools
    @property
    def return_values(self) -> List[str]:
        return ["output"]
    @abstractmethod
    def _extract_tool_and_input(self, text: str) -> Optional[Tuple[str, str]]:
        """Extract tool and tool input from llm output."""
    def _fix_text(self, text: str) -> str:
        """Fix the text."""
        raise ValueError("fix_text not implemented for this agent.")
    @property
    def _stop(self) -> List[str]:
        return [
            f"\n{self.observation_prefix.rstrip()}",
            f"\n\t{self.observation_prefix.rstrip()}",
Summary:
Agent class is the base class for all agents
 - It provides methods to extract tool and input from LLM output, as well as a method to fix text
 - It also contains properties such as return values and stop words 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_260-280
Code:
    intermediary work.
    """
    llm_chain: LLMChain
    allowed_tools: Optional[List[str]] = None
    def get_allowed_tools(self) -> Optional[List[str]]:
        return self.allowed_tools
    @property
    def return_values(self) -> List[str]:
        return ["output"]
    @abstractmethod
    def _extract_tool_and_input(self, text: str) -> Optional[Tuple[str, str]]:
        """Extract tool and tool input from llm output."""
    def _fix_text(self, text: str) -> str:
        """Fix the text."""
        raise ValueError("fix_text not implemented for this agent.")
    @property
    def _stop(self) -> List[str]:
        return [
            f"\n{self.observation_prefix.rstrip()}",
            f"\n\t{self.observation_prefix.rstrip()}",
Summary:
Agent class is the base class for all agents
 - It provides methods to extract tool and input from LLM output, as well as a method to fix text
 - It also contains properties such as return values and stop words 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_260-280
Code:
    intermediary work.
    """
    llm_chain: LLMChain
    allowed_tools: Optional[List[str]] = None
    def get_allowed_tools(self) -> Optional[List[str]]:
        return self.allowed_tools
    @property
    def return_values(self) -> List[str]:
        return ["output"]
    @abstractmethod
    def _extract_tool_and_input(self, text: str) -> Optional[Tuple[str, str]]:
        """Extract tool and tool input from llm output."""
    def _fix_text(self, text: str) -> str:
        """Fix the text."""
        raise ValueError("fix_text not implemented for this agent.")
    @property
    def _stop(self) -> List[str]:
        return [
            f"\n{self.observation_prefix.rstrip()}",
            f"\n\t{self.observation_prefix.rstrip()}",
Summary:
Agent class is the base class for all agents
 - It provides methods to extract tool and input from LLM output, as well as a method to fix text
 - It also contains properties such as return values and stop words 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_320-340
Code:
                along with observations
            **kwargs: User inputs.
        Returns:
            Action specifying what tool to use.
        """
        full_inputs = self.get_full_inputs(intermediate_steps, **kwargs)
        action = self._get_next_action(full_inputs)
        if action.tool == self.finish_tool_name:
            return AgentFinish({"output": action.tool_input}, action.log)
        return action
    async def aplan(
        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any
    ) -> Union[AgentAction, AgentFinish]:
        """Given input, decided what to do.
        Args:
            intermediate_steps: Steps the LLM has taken to date,
                along with observations
            **kwargs: User inputs.
        Returns:
            Action specifying what tool to use.
Summary:
Contains the Agent class, which is responsible for managing and executing tasks
 - Includes methods to get full inputs, get next action, plan actions and execute actions
 - Has a finish tool name attribute that specifies when an agent has finished its task 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_320-340
Code:
                along with observations
            **kwargs: User inputs.
        Returns:
            Action specifying what tool to use.
        """
        full_inputs = self.get_full_inputs(intermediate_steps, **kwargs)
        action = self._get_next_action(full_inputs)
        if action.tool == self.finish_tool_name:
            return AgentFinish({"output": action.tool_input}, action.log)
        return action
    async def aplan(
        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any
    ) -> Union[AgentAction, AgentFinish]:
        """Given input, decided what to do.
        Args:
            intermediate_steps: Steps the LLM has taken to date,
                along with observations
            **kwargs: User inputs.
        Returns:
            Action specifying what tool to use.
Summary:
Contains the Agent class, which is responsible for managing and executing tasks
 - Includes methods to get full inputs, get next action, plan actions and execute actions
 - Has a finish tool name attribute that specifies when an agent has finished its task 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_320-340
Code:
                along with observations
            **kwargs: User inputs.
        Returns:
            Action specifying what tool to use.
        """
        full_inputs = self.get_full_inputs(intermediate_steps, **kwargs)
        action = self._get_next_action(full_inputs)
        if action.tool == self.finish_tool_name:
            return AgentFinish({"output": action.tool_input}, action.log)
        return action
    async def aplan(
        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any
    ) -> Union[AgentAction, AgentFinish]:
        """Given input, decided what to do.
        Args:
            intermediate_steps: Steps the LLM has taken to date,
                along with observations
            **kwargs: User inputs.
        Returns:
            Action specifying what tool to use.
Summary:
Contains the Agent class, which is responsible for managing and executing tasks
 - Includes methods to get full inputs, get next action, plan actions and execute actions
 - Has a finish tool name attribute that specifies when an agent has finished its task 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_320-340
Code:
                along with observations
            **kwargs: User inputs.
        Returns:
            Action specifying what tool to use.
        """
        full_inputs = self.get_full_inputs(intermediate_steps, **kwargs)
        action = self._get_next_action(full_inputs)
        if action.tool == self.finish_tool_name:
            return AgentFinish({"output": action.tool_input}, action.log)
        return action
    async def aplan(
        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any
    ) -> Union[AgentAction, AgentFinish]:
        """Given input, decided what to do.
        Args:
            intermediate_steps: Steps the LLM has taken to date,
                along with observations
            **kwargs: User inputs.
        Returns:
            Action specifying what tool to use.
Summary:
Contains the Agent class, which is responsible for managing and executing tasks
 - Includes methods to get full inputs, get next action, plan actions and execute actions
 - Has a finish tool name attribute that specifies when an agent has finished its task 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_580-600
Code:
        result = []
        for agent_action in actions:
            self.callback_manager.on_agent_action(
                agent_action, verbose=self.verbose, color="green"
            )
            if agent_action.tool in name_to_tool_map:
                tool = name_to_tool_map[agent_action.tool]
                return_direct = tool.return_direct
                color = color_mapping[agent_action.tool]
                tool_run_kwargs = self.agent.tool_run_logging_kwargs()
                if return_direct:
                    tool_run_kwargs["llm_prefix"] = ""
                observation = tool.run(
                    agent_action.tool_input,
                    verbose=self.verbose,
                    color=color,
                    **tool_run_kwargs,
                )
            else:
                tool_run_kwargs = self.agent.tool_run_logging_kwargs()
Summary:
Contains code for the Agent class, which is responsible for running tools and managing their output
 - Includes methods to run a tool, log its output, and handle errors
 - Defines variables such as name_to_tool_map and color_mapping to store information about the tools being used 
- Utilizes callback manager to track agent actions ```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_580-600
Code:
        result = []
        for agent_action in actions:
            self.callback_manager.on_agent_action(
                agent_action, verbose=self.verbose, color="green"
            )
            if agent_action.tool in name_to_tool_map:
                tool = name_to_tool_map[agent_action.tool]
                return_direct = tool.return_direct
                color = color_mapping[agent_action.tool]
                tool_run_kwargs = self.agent.tool_run_logging_kwargs()
                if return_direct:
                    tool_run_kwargs["llm_prefix"] = ""
                observation = tool.run(
                    agent_action.tool_input,
                    verbose=self.verbose,
                    color=color,
                    **tool_run_kwargs,
                )
            else:
                tool_run_kwargs = self.agent.tool_run_logging_kwargs()
Summary:
Contains code for the Agent class, which is responsible for running tools and managing their output
 - Includes methods to run a tool, log its output, and handle errors
 - Defines variables such as name_to_tool_map and color_mapping to store information about the tools being used 
- Utilizes callback manager to track agent actions ```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_580-600
Code:
        result = []
        for agent_action in actions:
            self.callback_manager.on_agent_action(
                agent_action, verbose=self.verbose, color="green"
            )
            if agent_action.tool in name_to_tool_map:
                tool = name_to_tool_map[agent_action.tool]
                return_direct = tool.return_direct
                color = color_mapping[agent_action.tool]
                tool_run_kwargs = self.agent.tool_run_logging_kwargs()
                if return_direct:
                    tool_run_kwargs["llm_prefix"] = ""
                observation = tool.run(
                    agent_action.tool_input,
                    verbose=self.verbose,
                    color=color,
                    **tool_run_kwargs,
                )
            else:
                tool_run_kwargs = self.agent.tool_run_logging_kwargs()
Summary:
Contains code for the Agent class, which is responsible for running tools and managing their output
 - Includes methods to run a tool, log its output, and handle errors
 - Defines variables such as name_to_tool_map and color_mapping to store information about the tools being used 
- Utilizes callback manager to track agent actions ```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_580-600
Code:
        result = []
        for agent_action in actions:
            self.callback_manager.on_agent_action(
                agent_action, verbose=self.verbose, color="green"
            )
            if agent_action.tool in name_to_tool_map:
                tool = name_to_tool_map[agent_action.tool]
                return_direct = tool.return_direct
                color = color_mapping[agent_action.tool]
                tool_run_kwargs = self.agent.tool_run_logging_kwargs()
                if return_direct:
                    tool_run_kwargs["llm_prefix"] = ""
                observation = tool.run(
                    agent_action.tool_input,
                    verbose=self.verbose,
                    color=color,
                    **tool_run_kwargs,
                )
            else:
                tool_run_kwargs = self.agent.tool_run_logging_kwargs()
Summary:
Contains code for the Agent class, which is responsible for running tools and managing their output
 - Includes methods to run a tool, log its output, and handle errors
 - Defines variables such as name_to_tool_map and color_mapping to store information about the tools being used 
- Utilizes callback manager to track agent actions ```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_620-640
Code:
            return output
        actions: List[AgentAction]
        if isinstance(output, AgentAction):
            actions = [output]
        else:
            actions = output
        async def _aperform_agent_action(
            agent_action: AgentAction,
        ) -> Tuple[AgentAction, str]:
            if self.callback_manager.is_async:
                await self.callback_manager.on_agent_action(
                    agent_action, verbose=self.verbose, color="green"
                )
            else:
                self.callback_manager.on_agent_action(
                    agent_action, verbose=self.verbose, color="green"
                )
            if agent_action.tool in name_to_tool_map:
                tool = name_to_tool_map[agent_action.tool]
                return_direct = tool.return_direct
Summary:
Contains code for an Agent class, which is used to interact with the environment
 - Includes methods for performing agent actions and handling callbacks
 - Defines a mapping between tool names and their corresponding classes  ```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_620-640
Code:
            return output
        actions: List[AgentAction]
        if isinstance(output, AgentAction):
            actions = [output]
        else:
            actions = output
        async def _aperform_agent_action(
            agent_action: AgentAction,
        ) -> Tuple[AgentAction, str]:
            if self.callback_manager.is_async:
                await self.callback_manager.on_agent_action(
                    agent_action, verbose=self.verbose, color="green"
                )
            else:
                self.callback_manager.on_agent_action(
                    agent_action, verbose=self.verbose, color="green"
                )
            if agent_action.tool in name_to_tool_map:
                tool = name_to_tool_map[agent_action.tool]
                return_direct = tool.return_direct
Summary:
Contains code for an Agent class, which is used to interact with the environment
 - Includes methods for performing agent actions and handling callbacks
 - Defines a mapping between tool names and their corresponding classes  ```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_620-640
Code:
            return output
        actions: List[AgentAction]
        if isinstance(output, AgentAction):
            actions = [output]
        else:
            actions = output
        async def _aperform_agent_action(
            agent_action: AgentAction,
        ) -> Tuple[AgentAction, str]:
            if self.callback_manager.is_async:
                await self.callback_manager.on_agent_action(
                    agent_action, verbose=self.verbose, color="green"
                )
            else:
                self.callback_manager.on_agent_action(
                    agent_action, verbose=self.verbose, color="green"
                )
            if agent_action.tool in name_to_tool_map:
                tool = name_to_tool_map[agent_action.tool]
                return_direct = tool.return_direct
Summary:
Contains code for an Agent class, which is used to interact with the environment
 - Includes methods for performing agent actions and handling callbacks
 - Defines a mapping between tool names and their corresponding classes  ```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_620-640
Code:
            return output
        actions: List[AgentAction]
        if isinstance(output, AgentAction):
            actions = [output]
        else:
            actions = output
        async def _aperform_agent_action(
            agent_action: AgentAction,
        ) -> Tuple[AgentAction, str]:
            if self.callback_manager.is_async:
                await self.callback_manager.on_agent_action(
                    agent_action, verbose=self.verbose, color="green"
                )
            else:
                self.callback_manager.on_agent_action(
                    agent_action, verbose=self.verbose, color="green"
                )
            if agent_action.tool in name_to_tool_map:
                tool = name_to_tool_map[agent_action.tool]
                return_direct = tool.return_direct
Summary:
Contains code for an Agent class, which is used to interact with the environment
 - Includes methods for performing agent actions and handling callbacks
 - Defines a mapping between tool names and their corresponding classes  ```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_0-20
Code:
"""Chain that takes in an input and produces an action and action input."""
from __future__ import annotations
import asyncio
import json
import logging
import time
from abc import abstractmethod
from pathlib import Path
from typing import Any, Dict, List, Optional, Sequence, Tuple, Union
import yaml
from pydantic import BaseModel, root_validator
from langchain.agents.tools import InvalidTool
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains.base import Chain
from langchain.chains.llm import LLMChain
from langchain.input import get_color_mapping
from langchain.prompts.base import BasePromptTemplate
from langchain.prompts.few_shot import FewShotPromptTemplate
from langchain.prompts.prompt import PromptTemplate
from langchain.schema import (
Summary:
Defines the base class for all agents
 - Contains abstract methods to be implemented by subclasses
 - Includes a root validator method to validate data models
 - Implements an asyncio loop for running tasks in parallel 
 - Provides tools for loading and parsing YAML/JSON files 
 - Includes logging capabilities with different levels of severity 
 - Allows users to define custom color mappings when prompting user input 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_0-20
Code:
"""Chain that takes in an input and produces an action and action input."""
from __future__ import annotations
import asyncio
import json
import logging
import time
from abc import abstractmethod
from pathlib import Path
from typing import Any, Dict, List, Optional, Sequence, Tuple, Union
import yaml
from pydantic import BaseModel, root_validator
from langchain.agents.tools import InvalidTool
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains.base import Chain
from langchain.chains.llm import LLMChain
from langchain.input import get_color_mapping
from langchain.prompts.base import BasePromptTemplate
from langchain.prompts.few_shot import FewShotPromptTemplate
from langchain.prompts.prompt import PromptTemplate
from langchain.schema import (
Summary:
Defines the base class for all agents
 - Contains abstract methods to be implemented by subclasses
 - Includes a root validator method to validate data models
 - Implements an asyncio loop for running tasks in parallel 
 - Provides tools for loading and parsing YAML/JSON files 
 - Includes logging capabilities with different levels of severity 
 - Allows users to define custom color mappings when prompting user input 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_0-20
Code:
"""Chain that takes in an input and produces an action and action input."""
from __future__ import annotations
import asyncio
import json
import logging
import time
from abc import abstractmethod
from pathlib import Path
from typing import Any, Dict, List, Optional, Sequence, Tuple, Union
import yaml
from pydantic import BaseModel, root_validator
from langchain.agents.tools import InvalidTool
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains.base import Chain
from langchain.chains.llm import LLMChain
from langchain.input import get_color_mapping
from langchain.prompts.base import BasePromptTemplate
from langchain.prompts.few_shot import FewShotPromptTemplate
from langchain.prompts.prompt import PromptTemplate
from langchain.schema import (
Summary:
Defines the base class for all agents
 - Contains abstract methods to be implemented by subclasses
 - Includes a root validator method to validate data models
 - Implements an asyncio loop for running tasks in parallel 
 - Provides tools for loading and parsing YAML/JSON files 
 - Includes logging capabilities with different levels of severity 
 - Allows users to define custom color mappings when prompting user input 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_0-20
Code:
"""Chain that takes in an input and produces an action and action input."""
from __future__ import annotations
import asyncio
import json
import logging
import time
from abc import abstractmethod
from pathlib import Path
from typing import Any, Dict, List, Optional, Sequence, Tuple, Union
import yaml
from pydantic import BaseModel, root_validator
from langchain.agents.tools import InvalidTool
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains.base import Chain
from langchain.chains.llm import LLMChain
from langchain.input import get_color_mapping
from langchain.prompts.base import BasePromptTemplate
from langchain.prompts.few_shot import FewShotPromptTemplate
from langchain.prompts.prompt import PromptTemplate
from langchain.schema import (
Summary:
Defines the base class for all agents
 - Contains abstract methods to be implemented by subclasses
 - Includes a root validator method to validate data models
 - Implements an asyncio loop for running tasks in parallel 
 - Provides tools for loading and parsing YAML/JSON files 
 - Includes logging capabilities with different levels of severity 
 - Allows users to define custom color mappings when prompting user input 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:prompt.py
Code:
# flake8: noqa

PREFIX = """You are an agent designed to write and execute python code to answer questions.
You have access to a python REPL, which you can use to execute python code.
If you get an error, debug your code and try again.
Only use the output of your code to answer the question. 
You might know the answer without running any code, but you should still run the code to get the answer.
If it does not seem like you can write code to answer the question, just return "I don't know" as the answer.
"""

Summary:
Contains a SQL_PREFIX and SQL_SUFFIX string which provide instructions for the agent to interact with a SQL database.
 - The prefix provides instructions on how to create syntactically correct queries, limit results, order results by relevant columns, and not query all columns from a specific table. 
 - The suffix contains an input question that the agent should answer using information obtained from the database. 
 - It also includes an agent scratchpad where any notes or thoughts can be written down while constructing the query. 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:prompt.py
Code:
# flake8: noqa

PREFIX = """You are an agent designed to write and execute python code to answer questions.
You have access to a python REPL, which you can use to execute python code.
If you get an error, debug your code and try again.
Only use the output of your code to answer the question. 
You might know the answer without running any code, but you should still run the code to get the answer.
If it does not seem like you can write code to answer the question, just return "I don't know" as the answer.
"""

Summary:
Contains a SQL_PREFIX and SQL_SUFFIX string which provide instructions for the agent to interact with a SQL database.
 - The prefix provides instructions on how to create syntactically correct queries, limit results, order results by relevant columns, and not query all columns from a specific table. 
 - The suffix contains an input question that the agent should answer using information obtained from the database. 
 - It also includes an agent scratchpad where any notes or thoughts can be written down while constructing the query. 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:prompt.py
Code:
# flake8: noqa

PREFIX = """You are an agent designed to write and execute python code to answer questions.
You have access to a python REPL, which you can use to execute python code.
If you get an error, debug your code and try again.
Only use the output of your code to answer the question. 
You might know the answer without running any code, but you should still run the code to get the answer.
If it does not seem like you can write code to answer the question, just return "I don't know" as the answer.
"""

Summary:
Contains a SQL_PREFIX and SQL_SUFFIX string which provide instructions for the agent to interact with a SQL database.
 - The prefix provides instructions on how to create syntactically correct queries, limit results, order results by relevant columns, and not query all columns from a specific table. 
 - The suffix contains an input question that the agent should answer using information obtained from the database. 
 - It also includes an agent scratchpad where any notes or thoughts can be written down while constructing the query. 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:prompt.py
Code:
# flake8: noqa

PREFIX = """You are an agent designed to write and execute python code to answer questions.
You have access to a python REPL, which you can use to execute python code.
If you get an error, debug your code and try again.
Only use the output of your code to answer the question. 
You might know the answer without running any code, but you should still run the code to get the answer.
If it does not seem like you can write code to answer the question, just return "I don't know" as the answer.
"""

Summary:
Contains a SQL_PREFIX and SQL_SUFFIX string which provide instructions for the agent to interact with a SQL database.
 - The prefix provides instructions on how to create syntactically correct queries, limit results, order results by relevant columns, and not query all columns from a specific table. 
 - The suffix contains an input question that the agent should answer using information obtained from the database. 
 - It also includes an agent scratchpad where any notes or thoughts can be written down while constructing the query. 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:planner_prompt.py_chunk_60-80
Code:
Begin!
Plan: {input}
Thought:
{agent_scratchpad}
"""
API_CONTROLLER_TOOL_NAME = "api_controller"
API_CONTROLLER_TOOL_DESCRIPTION = f"Can be used to execute a plan of API calls, like {API_CONTROLLER_TOOL_NAME}(plan)."
API_ORCHESTRATOR_PROMPT = """You are an agent that assists with user queries against API, things like querying information or creating resources.
Some user queries can be resolved in a single API call, particularly if you can find appropriate params from the OpenAPI spec; though some require several API call.
You should always plan your API calls first, and then execute the plan second.
If the plan includes a DELETE call, be sure to ask the User for authorization first unless the User has specifically asked to delete something.
You should never return information without executing the api_controller tool.
Here are the tools to plan and execute API requests: {tool_descriptions}
Starting below, you should follow this format:
User query: the query a User wants help with related to the API
Thought: you should always think about what to do
Action: the action to take, should be one of the tools [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Summary:
A Python file that contains a prompt for the user to plan their API calls
 - Includes tools to help with planning and executing API requests
 - Contains descriptions of each tool, as well as instructions on how to use them 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:planner_prompt.py_chunk_60-80
Code:
Begin!
Plan: {input}
Thought:
{agent_scratchpad}
"""
API_CONTROLLER_TOOL_NAME = "api_controller"
API_CONTROLLER_TOOL_DESCRIPTION = f"Can be used to execute a plan of API calls, like {API_CONTROLLER_TOOL_NAME}(plan)."
API_ORCHESTRATOR_PROMPT = """You are an agent that assists with user queries against API, things like querying information or creating resources.
Some user queries can be resolved in a single API call, particularly if you can find appropriate params from the OpenAPI spec; though some require several API call.
You should always plan your API calls first, and then execute the plan second.
If the plan includes a DELETE call, be sure to ask the User for authorization first unless the User has specifically asked to delete something.
You should never return information without executing the api_controller tool.
Here are the tools to plan and execute API requests: {tool_descriptions}
Starting below, you should follow this format:
User query: the query a User wants help with related to the API
Thought: you should always think about what to do
Action: the action to take, should be one of the tools [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Summary:
A Python file that contains a prompt for the user to plan their API calls
 - Includes tools to help with planning and executing API requests
 - Contains descriptions of each tool, as well as instructions on how to use them 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:planner_prompt.py_chunk_60-80
Code:
Begin!
Plan: {input}
Thought:
{agent_scratchpad}
"""
API_CONTROLLER_TOOL_NAME = "api_controller"
API_CONTROLLER_TOOL_DESCRIPTION = f"Can be used to execute a plan of API calls, like {API_CONTROLLER_TOOL_NAME}(plan)."
API_ORCHESTRATOR_PROMPT = """You are an agent that assists with user queries against API, things like querying information or creating resources.
Some user queries can be resolved in a single API call, particularly if you can find appropriate params from the OpenAPI spec; though some require several API call.
You should always plan your API calls first, and then execute the plan second.
If the plan includes a DELETE call, be sure to ask the User for authorization first unless the User has specifically asked to delete something.
You should never return information without executing the api_controller tool.
Here are the tools to plan and execute API requests: {tool_descriptions}
Starting below, you should follow this format:
User query: the query a User wants help with related to the API
Thought: you should always think about what to do
Action: the action to take, should be one of the tools [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Summary:
A Python file that contains a prompt for the user to plan their API calls
 - Includes tools to help with planning and executing API requests
 - Contains descriptions of each tool, as well as instructions on how to use them 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:planner_prompt.py_chunk_60-80
Code:
Begin!
Plan: {input}
Thought:
{agent_scratchpad}
"""
API_CONTROLLER_TOOL_NAME = "api_controller"
API_CONTROLLER_TOOL_DESCRIPTION = f"Can be used to execute a plan of API calls, like {API_CONTROLLER_TOOL_NAME}(plan)."
API_ORCHESTRATOR_PROMPT = """You are an agent that assists with user queries against API, things like querying information or creating resources.
Some user queries can be resolved in a single API call, particularly if you can find appropriate params from the OpenAPI spec; though some require several API call.
You should always plan your API calls first, and then execute the plan second.
If the plan includes a DELETE call, be sure to ask the User for authorization first unless the User has specifically asked to delete something.
You should never return information without executing the api_controller tool.
Here are the tools to plan and execute API requests: {tool_descriptions}
Starting below, you should follow this format:
User query: the query a User wants help with related to the API
Thought: you should always think about what to do
Action: the action to take, should be one of the tools [{tool_names}]
Action Input: the input to the action
Observation: the result of the action
... (this Thought/Action/Action Input/Observation can repeat N times)
Summary:
A Python file that contains a prompt for the user to plan their API calls
 - Includes tools to help with planning and executing API requests
 - Contains descriptions of each tool, as well as instructions on how to use them 
```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:planner.py_chunk_140-160
Code:
    tools: List[BaseTool] = [
        RequestsGetToolWithParsing(requests_wrapper=requests_wrapper),
        RequestsPostToolWithParsing(requests_wrapper=requests_wrapper),
    ]
    prompt = PromptTemplate(
        template=API_CONTROLLER_PROMPT,
        input_variables=["input", "agent_scratchpad"],
        partial_variables={
            "api_url": api_url,
            "api_docs": api_docs,
            "tool_names": ", ".join([tool.name for tool in tools]),
            "tool_descriptions": "\n".join(
                [f"{tool.name}: {tool.description}" for tool in tools]
            ),
        },
    )
    agent = ZeroShotAgent(
        llm_chain=LLMChain(llm=llm, prompt=prompt),
        allowed_tools=[tool.name for tool in tools],
    )
Summary:
Defines a PromptTemplate class which is used to create prompts for the ZeroShotAgent
 - Contains an API_CONTROLLER_PROMPT template that takes in input and agent scratchpad variables
 - Allows for tools such as RequestsGetToolWithParsing and RequestsPostToolWithParsing to be added 
 - Creates a ZeroShotAgent with an LLMChain containing the prompt, and allows for specific tool names to be specified ```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:planner.py_chunk_140-160
Code:
    tools: List[BaseTool] = [
        RequestsGetToolWithParsing(requests_wrapper=requests_wrapper),
        RequestsPostToolWithParsing(requests_wrapper=requests_wrapper),
    ]
    prompt = PromptTemplate(
        template=API_CONTROLLER_PROMPT,
        input_variables=["input", "agent_scratchpad"],
        partial_variables={
            "api_url": api_url,
            "api_docs": api_docs,
            "tool_names": ", ".join([tool.name for tool in tools]),
            "tool_descriptions": "\n".join(
                [f"{tool.name}: {tool.description}" for tool in tools]
            ),
        },
    )
    agent = ZeroShotAgent(
        llm_chain=LLMChain(llm=llm, prompt=prompt),
        allowed_tools=[tool.name for tool in tools],
    )
Summary:
Defines a PromptTemplate class which is used to create prompts for the ZeroShotAgent
 - Contains an API_CONTROLLER_PROMPT template that takes in input and agent scratchpad variables
 - Allows for tools such as RequestsGetToolWithParsing and RequestsPostToolWithParsing to be added 
 - Creates a ZeroShotAgent with an LLMChain containing the prompt, and allows for specific tool names to be specified ```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:planner.py_chunk_140-160
Code:
    tools: List[BaseTool] = [
        RequestsGetToolWithParsing(requests_wrapper=requests_wrapper),
        RequestsPostToolWithParsing(requests_wrapper=requests_wrapper),
    ]
    prompt = PromptTemplate(
        template=API_CONTROLLER_PROMPT,
        input_variables=["input", "agent_scratchpad"],
        partial_variables={
            "api_url": api_url,
            "api_docs": api_docs,
            "tool_names": ", ".join([tool.name for tool in tools]),
            "tool_descriptions": "\n".join(
                [f"{tool.name}: {tool.description}" for tool in tools]
            ),
        },
    )
    agent = ZeroShotAgent(
        llm_chain=LLMChain(llm=llm, prompt=prompt),
        allowed_tools=[tool.name for tool in tools],
    )
Summary:
Defines a PromptTemplate class which is used to create prompts for the ZeroShotAgent
 - Contains an API_CONTROLLER_PROMPT template that takes in input and agent scratchpad variables
 - Allows for tools such as RequestsGetToolWithParsing and RequestsPostToolWithParsing to be added 
 - Creates a ZeroShotAgent with an LLMChain containing the prompt, and allows for specific tool names to be specified ```
[0m
2023-04-29 20:52:58 - PARSERO - [32m[47mINFO[0m - File:planner.py_chunk_140-160
Code:
    tools: List[BaseTool] = [
        RequestsGetToolWithParsing(requests_wrapper=requests_wrapper),
        RequestsPostToolWithParsing(requests_wrapper=requests_wrapper),
    ]
    prompt = PromptTemplate(
        template=API_CONTROLLER_PROMPT,
        input_variables=["input", "agent_scratchpad"],
        partial_variables={
            "api_url": api_url,
            "api_docs": api_docs,
            "tool_names": ", ".join([tool.name for tool in tools]),
            "tool_descriptions": "\n".join(
                [f"{tool.name}: {tool.description}" for tool in tools]
            ),
        },
    )
    agent = ZeroShotAgent(
        llm_chain=LLMChain(llm=llm, prompt=prompt),
        allowed_tools=[tool.name for tool in tools],
    )
Summary:
Defines a PromptTemplate class which is used to create prompts for the ZeroShotAgent
 - Contains an API_CONTROLLER_PROMPT template that takes in input and agent scratchpad variables
 - Allows for tools such as RequestsGetToolWithParsing and RequestsPostToolWithParsing to be added 
 - Creates a ZeroShotAgent with an LLMChain containing the prompt, and allows for specific tool names to be specified ```
[0m
2023-04-29 20:53:33 - SOTA_Logger - [31m[40mERROR[0m - Unexpected error: [0m
2023-04-29 20:54:36 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 20:54:37 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 20:54:37 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 20:54:37 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_300-320
Code:
            tool=parsed_output[0], tool_input=parsed_output[1], log=full_output
        )
    async def _aget_next_action(self, full_inputs: Dict[str, str]) -> AgentAction:
        full_output = await self.llm_chain.apredict(**full_inputs)
        parsed_output = self._extract_tool_and_input(full_output)
        while parsed_output is None:
            full_output = self._fix_text(full_output)
            full_inputs["agent_scratchpad"] += full_output
            output = await self.llm_chain.apredict(**full_inputs)
            full_output += output
            parsed_output = self._extract_tool_and_input(full_output)
        return AgentAction(
            tool=parsed_output[0], tool_input=parsed_output[1], log=full_output
        )
    def plan(
        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any
    ) -> Union[AgentAction, AgentFinish]:
        """Given input, decided what to do.
        Args:
            intermediate_steps: Steps the LLM has taken to date,
Summary:
Contains the Agent class, which is responsible for handling user input and providing output
 - Includes methods to extract tool and input from a given string of text
 - Has a plan method that takes in intermediate steps as an argument 
 - Includes an _aget_next_action method that uses the LLM chain to predict what action should be taken next based on user inputs ```
[0m
2023-04-29 20:54:37 - PARSERO - [32m[47mINFO[0m - File:planner.py_chunk_220-240
Code:
    agent = ZeroShotAgent(
        llm_chain=LLMChain(llm=llm, prompt=prompt, memory=shared_memory),
        allowed_tools=[tool.name for tool in tools],
    )
    return AgentExecutor.from_agent_and_tools(agent=agent, tools=tools, verbose=verbose)
Summary:
Implements a ZeroShotAgent class
 - Uses an LLMChain with a prompt and shared memory
 - Allows for the use of specific tools 
 - Creates an AgentExecutor from the agent and tools 
```
[0m
2023-04-29 20:54:37 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_540-560
Code:
        self.callback_manager.on_agent_finish(
            output, color="green", verbose=self.verbose
        )
        final_output = output.return_values
        if self.return_intermediate_steps:
            final_output["intermediate_steps"] = intermediate_steps
        return final_output
    async def _areturn(
        self, output: AgentFinish, intermediate_steps: list
    ) -> Dict[str, Any]:
        if self.callback_manager.is_async:
            await self.callback_manager.on_agent_finish(
                output, color="green", verbose=self.verbose
            )
        else:
            self.callback_manager.on_agent_finish(
                output, color="green", verbose=self.verbose
            )
        final_output = output.return_values
        if self.return_intermediate_steps:
Summary:
Contains the Agent class, which is responsible for running agents
 - Includes methods to run and return agent output
 - Has a callback manager that can be used to handle asynchronous calls
 - Allows users to specify whether or not they want intermediate steps returned in the final output ```
[0m
2023-04-29 20:54:37 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_420-440
Code:
        """Return response when agent has been stopped due to max iterations."""
        if early_stopping_method == "force":
            return AgentFinish(
                {"output": "Agent stopped due to iteration limit or time limit."}, ""
            )
        elif early_stopping_method == "generate":
            thoughts = ""
            for action, observation in intermediate_steps:
                thoughts += action.log
                thoughts += (
                    f"\n{self.observation_prefix}{observation}\n{self.llm_prefix}"
                )
            thoughts += (
                "\n\nI now need to return a final answer based on the previous steps:"
            )
            new_inputs = {"agent_scratchpad": thoughts, "stop": self._stop}
            full_inputs = {**kwargs, **new_inputs}
            full_output = self.llm_chain.predict(**full_inputs)
            parsed_output = self._extract_tool_and_input(full_output)
            if parsed_output is None:
Summary:
Contains the Agent class, which is used to create agents that can interact with a language model
 - Includes methods for training and evaluating an agent's performance
 - Has functions for early stopping of an agent based on iteration limit or time limit 
 - Allows users to extract tool and input from output generated by the language model chain  ```
[0m
2023-04-29 20:54:37 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_320-340
Code:
                along with observations
            **kwargs: User inputs.
        Returns:
            Action specifying what tool to use.
        """
        full_inputs = self.get_full_inputs(intermediate_steps, **kwargs)
        action = self._get_next_action(full_inputs)
        if action.tool == self.finish_tool_name:
            return AgentFinish({"output": action.tool_input}, action.log)
        return action
    async def aplan(
        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any
    ) -> Union[AgentAction, AgentFinish]:
        """Given input, decided what to do.
        Args:
            intermediate_steps: Steps the LLM has taken to date,
                along with observations
            **kwargs: User inputs.
        Returns:
            Action specifying what tool to use.
Summary:
Contains the Agent class, which is responsible for managing and executing tasks
 - Includes methods to get full inputs, get next action, plan actions and execute actions
 - Has a finish tool name attribute that specifies when an agent has finished its task 
```
[0m
2023-04-29 20:54:37 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:54:37 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:54:37 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""Chain that does self ask with search.

Heavily borrowed from https://github.com/ofirpress/self-ask
"""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:54:37 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0-20
Code:
"""An agent designed to hold a conversation in addition to using tools."""
from __future__ import annotations
import json
from typing import Any, List, Optional, Sequence, Tuple
from langchain.agents.agent import Agent
from langchain.agents.conversational_chat.prompt import (
    FORMAT_INSTRUCTIONS,
    PREFIX,
    SUFFIX,
    TEMPLATE_TOOL_RESPONSE,
)
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains import LLMChain
from langchain.prompts.base import BasePromptTemplate
from langchain.prompts.chat import (
    ChatPromptTemplate,
    HumanMessagePromptTemplate,
    MessagesPlaceholder,
    SystemMessagePromptTemplate,
)
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class called ReActDocstoreAgent which is an Agent for the ReAct chain
 - Includes properties such as _agent_type and _executor 
 - Has methods such as __init__, execute, and get_prompts 
 - Uses tools like Tool, BaseTool, Docstore, Document etc to optimize codebase```
[0m
2023-04-29 20:54:37 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0-20
Code:
"""Chain that implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf."""
import re
from typing import Any, List, Optional, Sequence, Tuple
from langchain.agents.agent import Agent, AgentExecutor
from langchain.agents.agent_types import AgentType
from langchain.agents.react.textworld_prompt import TEXTWORLD_PROMPT
from langchain.agents.react.wiki_prompt import WIKI_PROMPT
from langchain.agents.tools import Tool
from langchain.docstore.base import Docstore
from langchain.docstore.document import Document
from langchain.llms.base import BaseLLM
from langchain.prompts.base import BasePromptTemplate
from langchain.tools.base import BaseTool
class ReActDocstoreAgent(Agent):
    """Agent for the ReAct chain."""
    @property
    def _agent_type(self) -> str:
        """Return Identifier of agent type."""
        return AgentType.REACT_DOCSTORE
    @classmethod
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class called ReActDocstoreAgent which is an Agent for the ReAct chain
 - Includes properties such as _agent_type and _executor 
 - Has methods such as __init__, execute, and get_prompts 
 - Uses tools like Tool, BaseTool, Docstore, Document etc to optimize codebase```
[0m
2023-04-29 20:56:09 - SOTA_Logger - [31m[40mERROR[0m - Unexpected error: [0m
2023-04-29 20:56:23 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 20:56:23 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 20:56:24 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 20:56:24 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_540-560
Code:
        self.callback_manager.on_agent_finish(
            output, color="green", verbose=self.verbose
        )
        final_output = output.return_values
        if self.return_intermediate_steps:
            final_output["intermediate_steps"] = intermediate_steps
        return final_output
    async def _areturn(
        self, output: AgentFinish, intermediate_steps: list
    ) -> Dict[str, Any]:
        if self.callback_manager.is_async:
            await self.callback_manager.on_agent_finish(
                output, color="green", verbose=self.verbose
            )
        else:
            self.callback_manager.on_agent_finish(
                output, color="green", verbose=self.verbose
            )
        final_output = output.return_values
        if self.return_intermediate_steps:
Summary:
Contains the Agent class, which is responsible for running agents
 - Includes methods to run and return agent output
 - Has a callback manager that can be used to handle asynchronous calls
 - Allows users to specify whether or not they want intermediate steps returned in the final output ```
[0m
2023-04-29 20:56:24 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_580-600
Code:
        result = []
        for agent_action in actions:
            self.callback_manager.on_agent_action(
                agent_action, verbose=self.verbose, color="green"
            )
            if agent_action.tool in name_to_tool_map:
                tool = name_to_tool_map[agent_action.tool]
                return_direct = tool.return_direct
                color = color_mapping[agent_action.tool]
                tool_run_kwargs = self.agent.tool_run_logging_kwargs()
                if return_direct:
                    tool_run_kwargs["llm_prefix"] = ""
                observation = tool.run(
                    agent_action.tool_input,
                    verbose=self.verbose,
                    color=color,
                    **tool_run_kwargs,
                )
            else:
                tool_run_kwargs = self.agent.tool_run_logging_kwargs()
Summary:
Contains code for the Agent class, which is responsible for running tools and managing their output
 - Includes methods to run a tool, log its output, and handle errors
 - Defines variables such as name_to_tool_map and color_mapping to store information about the tools being used 
- Utilizes callback manager to track agent actions ```
[0m
2023-04-29 20:56:24 - PARSERO - [32m[47mINFO[0m - File:planner.py_chunk_220-240
Code:
    agent = ZeroShotAgent(
        llm_chain=LLMChain(llm=llm, prompt=prompt, memory=shared_memory),
        allowed_tools=[tool.name for tool in tools],
    )
    return AgentExecutor.from_agent_and_tools(agent=agent, tools=tools, verbose=verbose)
Summary:
Implements a ZeroShotAgent class
 - Uses an LLMChain with a prompt and shared memory
 - Allows for the use of specific tools 
 - Creates an AgentExecutor from the agent and tools 
```
[0m
2023-04-29 20:56:24 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_300-320
Code:
            tool=parsed_output[0], tool_input=parsed_output[1], log=full_output
        )
    async def _aget_next_action(self, full_inputs: Dict[str, str]) -> AgentAction:
        full_output = await self.llm_chain.apredict(**full_inputs)
        parsed_output = self._extract_tool_and_input(full_output)
        while parsed_output is None:
            full_output = self._fix_text(full_output)
            full_inputs["agent_scratchpad"] += full_output
            output = await self.llm_chain.apredict(**full_inputs)
            full_output += output
            parsed_output = self._extract_tool_and_input(full_output)
        return AgentAction(
            tool=parsed_output[0], tool_input=parsed_output[1], log=full_output
        )
    def plan(
        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any
    ) -> Union[AgentAction, AgentFinish]:
        """Given input, decided what to do.
        Args:
            intermediate_steps: Steps the LLM has taken to date,
Summary:
Contains the Agent class, which is responsible for handling user input and providing output
 - Includes methods to extract tool and input from a given string of text
 - Has a plan method that takes in intermediate steps as an argument 
 - Includes an _aget_next_action method that uses the LLM chain to predict what action should be taken next based on user inputs ```
[0m
2023-04-29 20:56:24 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_620-640
Code:
            return output
        actions: List[AgentAction]
        if isinstance(output, AgentAction):
            actions = [output]
        else:
            actions = output
        async def _aperform_agent_action(
            agent_action: AgentAction,
        ) -> Tuple[AgentAction, str]:
            if self.callback_manager.is_async:
                await self.callback_manager.on_agent_action(
                    agent_action, verbose=self.verbose, color="green"
                )
            else:
                self.callback_manager.on_agent_action(
                    agent_action, verbose=self.verbose, color="green"
                )
            if agent_action.tool in name_to_tool_map:
                tool = name_to_tool_map[agent_action.tool]
                return_direct = tool.return_direct
Summary:
Contains code for an Agent class, which is used to interact with the environment
 - Includes methods for performing agent actions and handling callbacks
 - Defines a mapping between tool names and their corresponding classes  ```
[0m
2023-04-29 20:56:24 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:56:24 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:56:24 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0-20
Code:
"""An agent designed to hold a conversation in addition to using tools."""
from __future__ import annotations
import json
from typing import Any, List, Optional, Sequence, Tuple
from langchain.agents.agent import Agent
from langchain.agents.conversational_chat.prompt import (
    FORMAT_INSTRUCTIONS,
    PREFIX,
    SUFFIX,
    TEMPLATE_TOOL_RESPONSE,
)
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains import LLMChain
from langchain.prompts.base import BasePromptTemplate
from langchain.prompts.chat import (
    ChatPromptTemplate,
    HumanMessagePromptTemplate,
    MessagesPlaceholder,
    SystemMessagePromptTemplate,
)
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class called ReActDocstoreAgent which is an Agent for the ReAct chain
 - Includes properties such as _agent_type and _executor 
 - Has methods such as __init__, execute, and get_prompts 
 - Uses tools like Tool, BaseTool, Docstore, Document etc to optimize codebase```
[0m
2023-04-29 20:56:24 - PARSERO - [32m[47mINFO[0m - File:prompt.py
Code:
# flake8: noqa

PREFIX = """You are an agent designed to write and execute python code to answer questions.
You have access to a python REPL, which you can use to execute python code.
If you get an error, debug your code and try again.
Only use the output of your code to answer the question. 
You might know the answer without running any code, but you should still run the code to get the answer.
If it does not seem like you can write code to answer the question, just return "I don't know" as the answer.
"""

Summary:
Contains a SQL_PREFIX and SQL_SUFFIX string which provide instructions for the agent to interact with a SQL database.
 - The prefix provides instructions on how to create syntactically correct queries, limit results, order results by relevant columns, and not query all columns from a specific table. 
 - The suffix contains an input question that the agent should answer using information obtained from the database. 
 - It also includes an agent scratchpad where any notes or thoughts can be written down while constructing the query. 
```
[0m
2023-04-29 20:56:24 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0-20
Code:
"""Json agent."""
from typing import Any, List, Optional
from langchain.agents.agent import AgentExecutor
from langchain.agents.agent_toolkits.json.prompt import JSON_PREFIX, JSON_SUFFIX
from langchain.agents.agent_toolkits.json.toolkit import JsonToolkit
from langchain.agents.mrkl.base import ZeroShotAgent
from langchain.agents.mrkl.prompt import FORMAT_INSTRUCTIONS
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains.llm import LLMChain
from langchain.llms.base import BaseLLM
def create_json_agent(
    llm: BaseLLM,
    toolkit: JsonToolkit,
    callback_manager: Optional[BaseCallbackManager] = None,
    prefix: str = JSON_PREFIX,
    suffix: str = JSON_SUFFIX,
    format_instructions: str = FORMAT_INSTRUCTIONS,
    input_variables: Optional[List[str]] = None,
    verbose: bool = False,
    **kwargs: Any,
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class called ReActDocstoreAgent which is an Agent for the ReAct chain
 - Includes properties such as _agent_type and _executor 
 - Has methods such as __init__, execute, and get_prompts 
 - Uses tools like Tool, BaseTool, Docstore, Document etc to optimize codebase```
[0m
2023-04-29 20:56:49 - SOTA_Logger - [31m[40mERROR[0m - Unexpected error: [0m
2023-04-29 20:56:56 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 20:56:57 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 20:56:57 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 20:56:57 - PARSERO - [32m[47mINFO[0m - File:planner.py_chunk_220-240
Code:
    agent = ZeroShotAgent(
        llm_chain=LLMChain(llm=llm, prompt=prompt, memory=shared_memory),
        allowed_tools=[tool.name for tool in tools],
    )
    return AgentExecutor.from_agent_and_tools(agent=agent, tools=tools, verbose=verbose)
Summary:
Implements a ZeroShotAgent class
 - Uses an LLMChain with a prompt and shared memory
 - Allows for the use of specific tools 
 - Creates an AgentExecutor from the agent and tools 
```
[0m
2023-04-29 20:56:57 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_300-320
Code:
            tool=parsed_output[0], tool_input=parsed_output[1], log=full_output
        )
    async def _aget_next_action(self, full_inputs: Dict[str, str]) -> AgentAction:
        full_output = await self.llm_chain.apredict(**full_inputs)
        parsed_output = self._extract_tool_and_input(full_output)
        while parsed_output is None:
            full_output = self._fix_text(full_output)
            full_inputs["agent_scratchpad"] += full_output
            output = await self.llm_chain.apredict(**full_inputs)
            full_output += output
            parsed_output = self._extract_tool_and_input(full_output)
        return AgentAction(
            tool=parsed_output[0], tool_input=parsed_output[1], log=full_output
        )
    def plan(
        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any
    ) -> Union[AgentAction, AgentFinish]:
        """Given input, decided what to do.
        Args:
            intermediate_steps: Steps the LLM has taken to date,
Summary:
Contains the Agent class, which is responsible for handling user input and providing output
 - Includes methods to extract tool and input from a given string of text
 - Has a plan method that takes in intermediate steps as an argument 
 - Includes an _aget_next_action method that uses the LLM chain to predict what action should be taken next based on user inputs ```
[0m
2023-04-29 20:56:57 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_540-560
Code:
        self.callback_manager.on_agent_finish(
            output, color="green", verbose=self.verbose
        )
        final_output = output.return_values
        if self.return_intermediate_steps:
            final_output["intermediate_steps"] = intermediate_steps
        return final_output
    async def _areturn(
        self, output: AgentFinish, intermediate_steps: list
    ) -> Dict[str, Any]:
        if self.callback_manager.is_async:
            await self.callback_manager.on_agent_finish(
                output, color="green", verbose=self.verbose
            )
        else:
            self.callback_manager.on_agent_finish(
                output, color="green", verbose=self.verbose
            )
        final_output = output.return_values
        if self.return_intermediate_steps:
Summary:
Contains the Agent class, which is responsible for running agents
 - Includes methods to run and return agent output
 - Has a callback manager that can be used to handle asynchronous calls
 - Allows users to specify whether or not they want intermediate steps returned in the final output ```
[0m
2023-04-29 20:56:57 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_580-600
Code:
        result = []
        for agent_action in actions:
            self.callback_manager.on_agent_action(
                agent_action, verbose=self.verbose, color="green"
            )
            if agent_action.tool in name_to_tool_map:
                tool = name_to_tool_map[agent_action.tool]
                return_direct = tool.return_direct
                color = color_mapping[agent_action.tool]
                tool_run_kwargs = self.agent.tool_run_logging_kwargs()
                if return_direct:
                    tool_run_kwargs["llm_prefix"] = ""
                observation = tool.run(
                    agent_action.tool_input,
                    verbose=self.verbose,
                    color=color,
                    **tool_run_kwargs,
                )
            else:
                tool_run_kwargs = self.agent.tool_run_logging_kwargs()
Summary:
Contains code for the Agent class, which is responsible for running tools and managing their output
 - Includes methods to run a tool, log its output, and handle errors
 - Defines variables such as name_to_tool_map and color_mapping to store information about the tools being used 
- Utilizes callback manager to track agent actions ```
[0m
2023-04-29 20:56:57 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_340-360
Code:
        """
        full_inputs = self.get_full_inputs(intermediate_steps, **kwargs)
        action = await self._aget_next_action(full_inputs)
        if action.tool == self.finish_tool_name:
            return AgentFinish({"output": action.tool_input}, action.log)
        return action
    def get_full_inputs(
        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any
    ) -> Dict[str, Any]:
        """Create the full inputs for the LLMChain from intermediate steps."""
        thoughts = self._construct_scratchpad(intermediate_steps)
        new_inputs = {"agent_scratchpad": thoughts, "stop": self._stop}
        full_inputs = {**kwargs, **new_inputs}
        return full_inputs
    @property
    def finish_tool_name(self) -> str:
        """Name of the tool to use to finish the chain."""
        return "Final Answer"
    @property
    def input_keys(self) -> List[str]:
Summary:
Agent class that implements the logic for an agent in a language chain
 - Contains methods to get the next action, construct scratchpad from intermediate steps, and finish the chain
 - Also contains properties such as input keys and finish tool name  ```
[0m
2023-04-29 20:56:57 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:56:57 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:56:57 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0-20
Code:
"""An agent designed to hold a conversation in addition to using tools."""
from __future__ import annotations
import json
from typing import Any, List, Optional, Sequence, Tuple
from langchain.agents.agent import Agent
from langchain.agents.conversational_chat.prompt import (
    FORMAT_INSTRUCTIONS,
    PREFIX,
    SUFFIX,
    TEMPLATE_TOOL_RESPONSE,
)
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains import LLMChain
from langchain.prompts.base import BasePromptTemplate
from langchain.prompts.chat import (
    ChatPromptTemplate,
    HumanMessagePromptTemplate,
    MessagesPlaceholder,
    SystemMessagePromptTemplate,
)
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class called ReActDocstoreAgent which is an Agent for the ReAct chain
 - Includes properties such as _agent_type and _executor 
 - Has methods such as __init__, execute, and get_prompts 
 - Uses tools like Tool, BaseTool, Docstore, Document etc to optimize codebase```
[0m
2023-04-29 20:56:57 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""Chain that does self ask with search.

Heavily borrowed from https://github.com/ofirpress/self-ask
"""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:56:57 - PARSERO - [32m[47mINFO[0m - File:planner.py_chunk_0-20
Code:
"""Agent that interacts with OpenAPI APIs via a hierarchical planning approach."""
import json
import re
from typing import List, Optional
import yaml
from langchain.agents.agent import AgentExecutor
from langchain.agents.agent_toolkits.openapi.planner_prompt import (
    API_CONTROLLER_PROMPT,
    API_CONTROLLER_TOOL_DESCRIPTION,
    API_CONTROLLER_TOOL_NAME,
    API_ORCHESTRATOR_PROMPT,
    API_PLANNER_PROMPT,
    API_PLANNER_TOOL_DESCRIPTION,
    API_PLANNER_TOOL_NAME,
    PARSING_DELETE_PROMPT,
    PARSING_GET_PROMPT,
    PARSING_PATCH_PROMPT,
    PARSING_POST_PROMPT,
    REQUESTS_DELETE_TOOL_DESCRIPTION,
    REQUESTS_GET_TOOL_DESCRIPTION,
Summary:
AgentExecutor class: This is the main class that interacts with OpenAPI APIs via a hierarchical planning approach.
 - API_CONTROLLER_PROMPT, API_CONTROLLER_TOOL_DESCRIPTION, and API_CONTROLLER_TOOL_NAME constants: These are used to define the controller tool for interacting with OpenAPI APIs. 
 - API_ORCHESTRATOR_PROMPT constant: This is used to define the orchestrator prompt for interacting with OpenAPI APIs. 
 - API _PLANNER _PROMPT, API _PLANNER _TOOL _DESCRIPTION, and API _PLANNER TOOL NAME constants: These are used to define the planner tool for interacting with OpenAPI APIs. 
 - PARSING DELETE PROMPT, PARSING GET PROMPT, PARSING PATCH PROMPT and PARSING POST PROMPT constants: These are used to parse requests from an OpenAPI spec file into their respective methods (GET/POST/PATCH/DELETE). 
- REQUESTS DELETE TOOL DESCRIPTION, REQUESTS GET TOOL DESCRIPTION etc.: These provide descriptions of each request type (GET/POST/PATCH/DELETE) when parsing an OpenAPI spec file. ```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_540-560
Code:
        self.callback_manager.on_agent_finish(
            output, color="green", verbose=self.verbose
        )
        final_output = output.return_values
        if self.return_intermediate_steps:
            final_output["intermediate_steps"] = intermediate_steps
        return final_output
    async def _areturn(
        self, output: AgentFinish, intermediate_steps: list
    ) -> Dict[str, Any]:
        if self.callback_manager.is_async:
            await self.callback_manager.on_agent_finish(
                output, color="green", verbose=self.verbose
            )
        else:
            self.callback_manager.on_agent_finish(
                output, color="green", verbose=self.verbose
            )
        final_output = output.return_values
        if self.return_intermediate_steps:
Summary:
Contains the Agent class, which is responsible for running agents
 - Includes methods to run and return agent output
 - Has a callback manager that can be used to handle asynchronous calls
 - Allows users to specify whether or not they want intermediate steps returned in the final output ```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_540-560
Code:
        self.callback_manager.on_agent_finish(
            output, color="green", verbose=self.verbose
        )
        final_output = output.return_values
        if self.return_intermediate_steps:
            final_output["intermediate_steps"] = intermediate_steps
        return final_output
    async def _areturn(
        self, output: AgentFinish, intermediate_steps: list
    ) -> Dict[str, Any]:
        if self.callback_manager.is_async:
            await self.callback_manager.on_agent_finish(
                output, color="green", verbose=self.verbose
            )
        else:
            self.callback_manager.on_agent_finish(
                output, color="green", verbose=self.verbose
            )
        final_output = output.return_values
        if self.return_intermediate_steps:
Summary:
Contains the Agent class, which is responsible for running agents
 - Includes methods to run and return agent output
 - Has a callback manager that can be used to handle asynchronous calls
 - Allows users to specify whether or not they want intermediate steps returned in the final output ```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_420-440
Code:
        """Return response when agent has been stopped due to max iterations."""
        if early_stopping_method == "force":
            return AgentFinish(
                {"output": "Agent stopped due to iteration limit or time limit."}, ""
            )
        elif early_stopping_method == "generate":
            thoughts = ""
            for action, observation in intermediate_steps:
                thoughts += action.log
                thoughts += (
                    f"\n{self.observation_prefix}{observation}\n{self.llm_prefix}"
                )
            thoughts += (
                "\n\nI now need to return a final answer based on the previous steps:"
            )
            new_inputs = {"agent_scratchpad": thoughts, "stop": self._stop}
            full_inputs = {**kwargs, **new_inputs}
            full_output = self.llm_chain.predict(**full_inputs)
            parsed_output = self._extract_tool_and_input(full_output)
            if parsed_output is None:
Summary:
Contains the Agent class, which is used to create agents that can interact with a language model
 - Includes methods for training and evaluating an agent's performance
 - Has functions for early stopping of an agent based on iteration limit or time limit 
 - Allows users to extract tool and input from output generated by the language model chain  ```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_420-440
Code:
        """Return response when agent has been stopped due to max iterations."""
        if early_stopping_method == "force":
            return AgentFinish(
                {"output": "Agent stopped due to iteration limit or time limit."}, ""
            )
        elif early_stopping_method == "generate":
            thoughts = ""
            for action, observation in intermediate_steps:
                thoughts += action.log
                thoughts += (
                    f"\n{self.observation_prefix}{observation}\n{self.llm_prefix}"
                )
            thoughts += (
                "\n\nI now need to return a final answer based on the previous steps:"
            )
            new_inputs = {"agent_scratchpad": thoughts, "stop": self._stop}
            full_inputs = {**kwargs, **new_inputs}
            full_output = self.llm_chain.predict(**full_inputs)
            parsed_output = self._extract_tool_and_input(full_output)
            if parsed_output is None:
Summary:
Contains the Agent class, which is used to create agents that can interact with a language model
 - Includes methods for training and evaluating an agent's performance
 - Has functions for early stopping of an agent based on iteration limit or time limit 
 - Allows users to extract tool and input from output generated by the language model chain  ```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_580-600
Code:
        result = []
        for agent_action in actions:
            self.callback_manager.on_agent_action(
                agent_action, verbose=self.verbose, color="green"
            )
            if agent_action.tool in name_to_tool_map:
                tool = name_to_tool_map[agent_action.tool]
                return_direct = tool.return_direct
                color = color_mapping[agent_action.tool]
                tool_run_kwargs = self.agent.tool_run_logging_kwargs()
                if return_direct:
                    tool_run_kwargs["llm_prefix"] = ""
                observation = tool.run(
                    agent_action.tool_input,
                    verbose=self.verbose,
                    color=color,
                    **tool_run_kwargs,
                )
            else:
                tool_run_kwargs = self.agent.tool_run_logging_kwargs()
Summary:
Contains code for the Agent class, which is responsible for running tools and managing their output
 - Includes methods to run a tool, log its output, and handle errors
 - Defines variables such as name_to_tool_map and color_mapping to store information about the tools being used 
- Utilizes callback manager to track agent actions ```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_580-600
Code:
        result = []
        for agent_action in actions:
            self.callback_manager.on_agent_action(
                agent_action, verbose=self.verbose, color="green"
            )
            if agent_action.tool in name_to_tool_map:
                tool = name_to_tool_map[agent_action.tool]
                return_direct = tool.return_direct
                color = color_mapping[agent_action.tool]
                tool_run_kwargs = self.agent.tool_run_logging_kwargs()
                if return_direct:
                    tool_run_kwargs["llm_prefix"] = ""
                observation = tool.run(
                    agent_action.tool_input,
                    verbose=self.verbose,
                    color=color,
                    **tool_run_kwargs,
                )
            else:
                tool_run_kwargs = self.agent.tool_run_logging_kwargs()
Summary:
Contains code for the Agent class, which is responsible for running tools and managing their output
 - Includes methods to run a tool, log its output, and handle errors
 - Defines variables such as name_to_tool_map and color_mapping to store information about the tools being used 
- Utilizes callback manager to track agent actions ```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_300-320
Code:
            tool=parsed_output[0], tool_input=parsed_output[1], log=full_output
        )
    async def _aget_next_action(self, full_inputs: Dict[str, str]) -> AgentAction:
        full_output = await self.llm_chain.apredict(**full_inputs)
        parsed_output = self._extract_tool_and_input(full_output)
        while parsed_output is None:
            full_output = self._fix_text(full_output)
            full_inputs["agent_scratchpad"] += full_output
            output = await self.llm_chain.apredict(**full_inputs)
            full_output += output
            parsed_output = self._extract_tool_and_input(full_output)
        return AgentAction(
            tool=parsed_output[0], tool_input=parsed_output[1], log=full_output
        )
    def plan(
        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any
    ) -> Union[AgentAction, AgentFinish]:
        """Given input, decided what to do.
        Args:
            intermediate_steps: Steps the LLM has taken to date,
Summary:
Contains the Agent class, which is responsible for handling user input and providing output
 - Includes methods to extract tool and input from a given string of text
 - Has a plan method that takes in intermediate steps as an argument 
 - Includes an _aget_next_action method that uses the LLM chain to predict what action should be taken next based on user inputs ```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_300-320
Code:
            tool=parsed_output[0], tool_input=parsed_output[1], log=full_output
        )
    async def _aget_next_action(self, full_inputs: Dict[str, str]) -> AgentAction:
        full_output = await self.llm_chain.apredict(**full_inputs)
        parsed_output = self._extract_tool_and_input(full_output)
        while parsed_output is None:
            full_output = self._fix_text(full_output)
            full_inputs["agent_scratchpad"] += full_output
            output = await self.llm_chain.apredict(**full_inputs)
            full_output += output
            parsed_output = self._extract_tool_and_input(full_output)
        return AgentAction(
            tool=parsed_output[0], tool_input=parsed_output[1], log=full_output
        )
    def plan(
        self, intermediate_steps: List[Tuple[AgentAction, str]], **kwargs: Any
    ) -> Union[AgentAction, AgentFinish]:
        """Given input, decided what to do.
        Args:
            intermediate_steps: Steps the LLM has taken to date,
Summary:
Contains the Agent class, which is responsible for handling user input and providing output
 - Includes methods to extract tool and input from a given string of text
 - Has a plan method that takes in intermediate steps as an argument 
 - Includes an _aget_next_action method that uses the LLM chain to predict what action should be taken next based on user inputs ```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_0-20
Code:
"""Chain that takes in an input and produces an action and action input."""
from __future__ import annotations
import asyncio
import json
import logging
import time
from abc import abstractmethod
from pathlib import Path
from typing import Any, Dict, List, Optional, Sequence, Tuple, Union
import yaml
from pydantic import BaseModel, root_validator
from langchain.agents.tools import InvalidTool
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains.base import Chain
from langchain.chains.llm import LLMChain
from langchain.input import get_color_mapping
from langchain.prompts.base import BasePromptTemplate
from langchain.prompts.few_shot import FewShotPromptTemplate
from langchain.prompts.prompt import PromptTemplate
from langchain.schema import (
Summary:
Defines the base class for all agents
 - Contains abstract methods to be implemented by subclasses
 - Includes a root validator method to validate data models
 - Implements an asyncio loop for running tasks in parallel 
 - Provides tools for loading and parsing YAML/JSON files 
 - Includes logging capabilities with different levels of severity 
 - Allows users to define custom color mappings when prompting user input 
```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_0-20
Code:
"""Chain that takes in an input and produces an action and action input."""
from __future__ import annotations
import asyncio
import json
import logging
import time
from abc import abstractmethod
from pathlib import Path
from typing import Any, Dict, List, Optional, Sequence, Tuple, Union
import yaml
from pydantic import BaseModel, root_validator
from langchain.agents.tools import InvalidTool
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains.base import Chain
from langchain.chains.llm import LLMChain
from langchain.input import get_color_mapping
from langchain.prompts.base import BasePromptTemplate
from langchain.prompts.few_shot import FewShotPromptTemplate
from langchain.prompts.prompt import PromptTemplate
from langchain.schema import (
Summary:
Defines the base class for all agents
 - Contains abstract methods to be implemented by subclasses
 - Includes a root validator method to validate data models
 - Implements an asyncio loop for running tasks in parallel 
 - Provides tools for loading and parsing YAML/JSON files 
 - Includes logging capabilities with different levels of severity 
 - Allows users to define custom color mappings when prompting user input 
```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""An agent designed to hold a conversation in addition to using tools."""

Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class for creating and training agents using reinforcement learning 
 - Includes functions to interact with an environment, select actions, and update agent parameters 
 - Utilizes deep neural networks to represent policies and value functions 
 - Supports multiple algorithms such as DQN, A2C, PPO, etc. ```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0-20
Code:
"""An agent designed to hold a conversation in addition to using tools."""
from __future__ import annotations
import json
from typing import Any, List, Optional, Sequence, Tuple
from langchain.agents.agent import Agent
from langchain.agents.conversational_chat.prompt import (
    FORMAT_INSTRUCTIONS,
    PREFIX,
    SUFFIX,
    TEMPLATE_TOOL_RESPONSE,
)
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains import LLMChain
from langchain.prompts.base import BasePromptTemplate
from langchain.prompts.chat import (
    ChatPromptTemplate,
    HumanMessagePromptTemplate,
    MessagesPlaceholder,
    SystemMessagePromptTemplate,
)
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class called ReActDocstoreAgent which is an Agent for the ReAct chain
 - Includes properties such as _agent_type and _executor 
 - Has methods such as __init__, execute, and get_prompts 
 - Uses tools like Tool, BaseTool, Docstore, Document etc to optimize codebase```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0-20
Code:
"""An agent designed to hold a conversation in addition to using tools."""
from __future__ import annotations
import json
from typing import Any, List, Optional, Sequence, Tuple
from langchain.agents.agent import Agent
from langchain.agents.conversational_chat.prompt import (
    FORMAT_INSTRUCTIONS,
    PREFIX,
    SUFFIX,
    TEMPLATE_TOOL_RESPONSE,
)
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains import LLMChain
from langchain.prompts.base import BasePromptTemplate
from langchain.prompts.chat import (
    ChatPromptTemplate,
    HumanMessagePromptTemplate,
    MessagesPlaceholder,
    SystemMessagePromptTemplate,
)
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class called ReActDocstoreAgent which is an Agent for the ReAct chain
 - Includes properties such as _agent_type and _executor 
 - Has methods such as __init__, execute, and get_prompts 
 - Uses tools like Tool, BaseTool, Docstore, Document etc to optimize codebase```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:__init__.py_chunk_0-20
Code:
"""Interface for agents."""
from langchain.agents.agent import (
    Agent,
    AgentExecutor,
    AgentOutputParser,
    BaseMultiActionAgent,
    BaseSingleActionAgent,
    LLMSingleActionAgent,
)
from langchain.agents.agent_toolkits import (
    create_csv_agent,
    create_json_agent,
    create_openapi_agent,
    create_pandas_dataframe_agent,
    create_sql_agent,
    create_vectorstore_agent,
    create_vectorstore_router_agent,
)
from langchain.agents.agent_types import AgentType
from langchain.agents.conversational.base import ConversationalAgent
Summary:
Create CSV Agent
 - Create JSON Agent
 - JsonToolkit for manipulating JSON data
 - NLAToolkit for Natural Language Processing tasks 
 - Create OpenAPI Agent 
 - OpenAPIToolkit to interact with APIs 
 - Create Pandas Dataframe Agent 
 - Create Python Agent  
- SQLDatabaseToolkit to manipulate databases and tables in SQL format 
- VectorStoreInfo class to store vectorized data  
- VectorStoreRouterToolkit to route requests between different vector stores   					    	     	      	       	        	          VectorStoreToolkit for interacting with the vector store.```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:__init__.py_chunk_0-20
Code:
"""Interface for agents."""
from langchain.agents.agent import (
    Agent,
    AgentExecutor,
    AgentOutputParser,
    BaseMultiActionAgent,
    BaseSingleActionAgent,
    LLMSingleActionAgent,
)
from langchain.agents.agent_toolkits import (
    create_csv_agent,
    create_json_agent,
    create_openapi_agent,
    create_pandas_dataframe_agent,
    create_sql_agent,
    create_vectorstore_agent,
    create_vectorstore_router_agent,
)
from langchain.agents.agent_types import AgentType
from langchain.agents.conversational.base import ConversationalAgent
Summary:
Create CSV Agent
 - Create JSON Agent
 - JsonToolkit for manipulating JSON data
 - NLAToolkit for Natural Language Processing tasks 
 - Create OpenAPI Agent 
 - OpenAPIToolkit to interact with APIs 
 - Create Pandas Dataframe Agent 
 - Create Python Agent  
- SQLDatabaseToolkit to manipulate databases and tables in SQL format 
- VectorStoreInfo class to store vectorized data  
- VectorStoreRouterToolkit to route requests between different vector stores   					    	     	      	       	        	          VectorStoreToolkit for interacting with the vector store.```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0-20
Code:
"""Json agent."""
from typing import Any, List, Optional
from langchain.agents.agent import AgentExecutor
from langchain.agents.agent_toolkits.json.prompt import JSON_PREFIX, JSON_SUFFIX
from langchain.agents.agent_toolkits.json.toolkit import JsonToolkit
from langchain.agents.mrkl.base import ZeroShotAgent
from langchain.agents.mrkl.prompt import FORMAT_INSTRUCTIONS
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains.llm import LLMChain
from langchain.llms.base import BaseLLM
def create_json_agent(
    llm: BaseLLM,
    toolkit: JsonToolkit,
    callback_manager: Optional[BaseCallbackManager] = None,
    prefix: str = JSON_PREFIX,
    suffix: str = JSON_SUFFIX,
    format_instructions: str = FORMAT_INSTRUCTIONS,
    input_variables: Optional[List[str]] = None,
    verbose: bool = False,
    **kwargs: Any,
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class called ReActDocstoreAgent which is an Agent for the ReAct chain
 - Includes properties such as _agent_type and _executor 
 - Has methods such as __init__, execute, and get_prompts 
 - Uses tools like Tool, BaseTool, Docstore, Document etc to optimize codebase```
[0m
2023-04-29 20:57:33 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0-20
Code:
"""Json agent."""
from typing import Any, List, Optional
from langchain.agents.agent import AgentExecutor
from langchain.agents.agent_toolkits.json.prompt import JSON_PREFIX, JSON_SUFFIX
from langchain.agents.agent_toolkits.json.toolkit import JsonToolkit
from langchain.agents.mrkl.base import ZeroShotAgent
from langchain.agents.mrkl.prompt import FORMAT_INSTRUCTIONS
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains.llm import LLMChain
from langchain.llms.base import BaseLLM
def create_json_agent(
    llm: BaseLLM,
    toolkit: JsonToolkit,
    callback_manager: Optional[BaseCallbackManager] = None,
    prefix: str = JSON_PREFIX,
    suffix: str = JSON_SUFFIX,
    format_instructions: str = FORMAT_INSTRUCTIONS,
    input_variables: Optional[List[str]] = None,
    verbose: bool = False,
    **kwargs: Any,
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class called ReActDocstoreAgent which is an Agent for the ReAct chain
 - Includes properties such as _agent_type and _executor 
 - Has methods such as __init__, execute, and get_prompts 
 - Uses tools like Tool, BaseTool, Docstore, Document etc to optimize codebase```
[0m
2023-04-29 20:58:35 - SOTA_Logger - [31m[40mERROR[0m - Unexpected error: [0m
2023-04-29 21:01:34 - SOTA_Logger - [32m[47mINFO[0m - Summarizing langchain/langchain/tools/arxiv/
Using 30 context chunks
Prompt: What does this code do?[0m
2023-04-29 21:01:34 - index_codebase - [32m[47mINFO[0m - Tokenizing code: 25[0m
2023-04-29 21:01:34 - index_codebase - [32m[47mINFO[0m - Tokenizing code: 947[0m
2023-04-29 21:01:34 - index_codebase - [32m[47mINFO[0m - New DF has 2 rows with 972 tokens[0m
2023-04-29 21:01:35 - Indexing codebase - [32m[47mINFO[0m - Indexed 2 rows[0m
2023-04-29 21:01:35 - SOTA_Logger - [32m[47mINFO[0m - Generating summary...[0m
2023-04-29 21:01:35 - SOTA_Logger - [32m[47mINFO[0m - Writing summary...[0m
2023-04-29 21:01:35 - Summary Logger - [32m[47mINFO[0m - Token length is 175 for /Users/clockcoin/parsero/langchain/langchain/tools/arxiv/__init__.py chunk[0m
2023-04-29 21:01:38 - Summary Logger - [32m[47mINFO[0m - Token length is 583 for /Users/clockcoin/parsero/langchain/langchain/tools/arxiv/tool.py chunk[0m
2023-04-29 21:01:41 - SOTA_Logger - [32m[47mINFO[0m - Saving embedding summary to /Users/clockcoin/parsero/langchain/langchain/tools/arxiv[0m
2023-04-29 21:01:41 - SOTA_Logger - [32m[47mINFO[0m - Processing summaries[0m
2023-04-29 21:01:41 - SOTA_Logger - [32m[47mINFO[0m - Embeddings saved to Usersclockcoinparserolangchainlangchaintoolsarxivpkl[0m
2023-04-29 21:01:47 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 21:01:47 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 21:01:47 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 21:01:47 - PARSERO - [32m[47mINFO[0m - File:tool.py
Code:
"""Tool for the Arxiv API."""

from langchain.tools.base import BaseTool
from langchain.utilities.arxiv import ArxivAPIWrapper


Summary:
Tool that adds the capability to search using the Arxiv API
 - Wrapper around Arxiv.org 
 - Useful for when you need to answer questions about Physics, Mathematics, Computer Science, Quantitative Biology, Quantitative Finance, Statistics, Electrical Engineering and Economics from scientific articles on arxiv.org
 - Input should be a search query
[0m
2023-04-29 21:01:47 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""Arxiv API toolkit."""

Summary:
Parses the Arxiv API for metadata and content
 - Uses a moving window approach to chunk the code into smaller pieces
 - Extracts relevant information from each chunk, such as title, authors, abstracts, etc. 
 - Stores this data in a structured format for further analysis
[0m
2023-04-29 21:01:47 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""Arxiv API toolkit."""

Summary:
Parses the Arxiv API for metadata and content
 - Uses a moving window approach to chunk the code into smaller pieces
 - Extracts relevant information from each chunk, such as title, authors, abstracts, etc. 
 - Stores this data in a structured format for further analysis
[0m
2023-04-29 21:01:47 - PARSERO - [32m[47mINFO[0m - File:tool.py
Code:
"""Tool for the Arxiv API."""

from langchain.tools.base import BaseTool
from langchain.utilities.arxiv import ArxivAPIWrapper


Summary:
Tool that adds the capability to search using the Arxiv API
 - Wrapper around Arxiv.org 
 - Useful for when you need to answer questions about Physics, Mathematics, Computer Science, Quantitative Biology, Quantitative Finance, Statistics, Electrical Engineering and Economics from scientific articles on arxiv.org
 - Input should be a search query
[0m
2023-04-29 21:04:14 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 21:04:14 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 21:04:14 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 21:04:14 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 21:04:14 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 21:04:14 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 21:04:14 - PARSERO - [32m[47mINFO[0m - File:tool.py
Code:
"""Tool for the Arxiv API."""

from langchain.tools.base import BaseTool
from langchain.utilities.arxiv import ArxivAPIWrapper


Summary:
Tool that adds the capability to search using the Arxiv API
 - Wrapper around Arxiv.org 
 - Useful for when you need to answer questions about Physics, Mathematics, Computer Science, Quantitative Biology, Quantitative Finance, Statistics, Electrical Engineering and Economics from scientific articles on arxiv.org
 - Input should be a search query
[0m
2023-04-29 21:04:14 - PARSERO - [32m[47mINFO[0m - File:tool.py
Code:
"""Tool for the Arxiv API."""

from langchain.tools.base import BaseTool
from langchain.utilities.arxiv import ArxivAPIWrapper


Summary:
Tool that adds the capability to search using the Arxiv API
 - Wrapper around Arxiv.org 
 - Useful for when you need to answer questions about Physics, Mathematics, Computer Science, Quantitative Biology, Quantitative Finance, Statistics, Electrical Engineering and Economics from scientific articles on arxiv.org
 - Input should be a search query
[0m
2023-04-29 21:04:14 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""Arxiv API toolkit."""

Summary:
Parses the Arxiv API for metadata and content
 - Uses a moving window approach to chunk the code into smaller pieces
 - Extracts relevant information from each chunk, such as title, authors, abstracts, etc. 
 - Stores this data in a structured format for further analysis
[0m
2023-04-29 21:04:14 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""Arxiv API toolkit."""

Summary:
Parses the Arxiv API for metadata and content
 - Uses a moving window approach to chunk the code into smaller pieces
 - Extracts relevant information from each chunk, such as title, authors, abstracts, etc. 
 - Stores this data in a structured format for further analysis
[0m
2023-04-29 21:04:14 - PARSERO - [32m[47mINFO[0m - File:tool.py
Code:
"""Tool for the Arxiv API."""

from langchain.tools.base import BaseTool
from langchain.utilities.arxiv import ArxivAPIWrapper


Summary:
Tool that adds the capability to search using the Arxiv API
 - Wrapper around Arxiv.org 
 - Useful for when you need to answer questions about Physics, Mathematics, Computer Science, Quantitative Biology, Quantitative Finance, Statistics, Electrical Engineering and Economics from scientific articles on arxiv.org
 - Input should be a search query
[0m
2023-04-29 21:04:14 - PARSERO - [32m[47mINFO[0m - File:tool.py
Code:
"""Tool for the Arxiv API."""

from langchain.tools.base import BaseTool
from langchain.utilities.arxiv import ArxivAPIWrapper


Summary:
Tool that adds the capability to search using the Arxiv API
 - Wrapper around Arxiv.org 
 - Useful for when you need to answer questions about Physics, Mathematics, Computer Science, Quantitative Biology, Quantitative Finance, Statistics, Electrical Engineering and Economics from scientific articles on arxiv.org
 - Input should be a search query
[0m
2023-04-29 21:04:14 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""Arxiv API toolkit."""

Summary:
Parses the Arxiv API for metadata and content
 - Uses a moving window approach to chunk the code into smaller pieces
 - Extracts relevant information from each chunk, such as title, authors, abstracts, etc. 
 - Stores this data in a structured format for further analysis
[0m
2023-04-29 21:04:14 - PARSERO - [32m[47mINFO[0m - File:__init__.py
Code:
"""Arxiv API toolkit."""

Summary:
Parses the Arxiv API for metadata and content
 - Uses a moving window approach to chunk the code into smaller pieces
 - Extracts relevant information from each chunk, such as title, authors, abstracts, etc. 
 - Stores this data in a structured format for further analysis
[0m
2023-04-29 21:04:31 - SOTA_Logger - [31m[40mERROR[0m - Unexpected error: [0m
2023-04-29 21:05:01 - SOTA_Logger - [32m[47mINFO[0m - Summarizing langchain/langchain/tools/arxiv/
Using 30 context chunks
Prompt: What does this code do?[0m
2023-04-29 21:05:01 - index_codebase - [32m[47mINFO[0m - Tokenizing code: 25[0m
2023-04-29 21:05:01 - index_codebase - [32m[47mINFO[0m - Tokenizing code: 947[0m
2023-04-29 21:05:01 - index_codebase - [32m[47mINFO[0m - New DF has 2 rows with 972 tokens[0m
2023-04-29 21:05:01 - Indexing codebase - [32m[47mINFO[0m - Indexed 2 rows[0m
2023-04-29 21:05:01 - SOTA_Logger - [32m[47mINFO[0m - Generating summary...[0m
2023-04-29 21:05:01 - SOTA_Logger - [32m[47mINFO[0m - Writing summary...[0m
2023-04-29 21:05:01 - Summary Logger - [32m[47mINFO[0m - Token length is 175 for /Users/clockcoin/parsero/langchain/langchain/tools/arxiv/__init__.py chunk[0m
2023-04-29 21:05:18 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 21:05:19 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 21:05:19 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 21:05:19 - PARSERO - [32m[47mINFO[0m - File:wiki_prompt.py_chunk_40-60
Code:
Action: Search[Elia Kazan]
Observation: Elia Kazan was an American film and theatre director, producer, screenwriter and actor.
Thought: Professions of Elia Kazan are director, producer, screenwriter, and actor. So profession Nicholas Ray and Elia Kazan have in common is director, screenwriter, and actor.
Action: Finish[director, screenwriter, actor]""",
    """Question: Which magazine was started first Arthurâ€™s Magazine or First for Women?
Thought: I need to search Arthurâ€™s Magazine and First for Women, and find which was started first.
Action: Search[Arthurâ€™s Magazine]
Observation: Arthurâ€™s Magazine (1844-1846) was an American literary periodical published in Philadelphia in the 19th century.
Thought: Arthurâ€™s Magazine was started in 1844. I need to search First for Women next.
Action: Search[First for Women]
Observation: First for Women is a womanâ€™s magazine published by Bauer Media Group in the USA.[1] The magazine was started in 1989.
Thought: First for Women was started in 1989. 1844 (Arthurâ€™s Magazine) < 1989 (First for Women), so Arthurâ€™s Magazine was started first.
Action: Finish[Arthurâ€™s Magazine]""",
    """Question: Were Pavel Urysohn and Leonid Levin known for the same type of work?
Thought: I need to search Pavel Urysohn and Leonid Levin, find their types of work, then find if they are the same.
Action: Search[Pavel Urysohn]
Observation: Pavel Samuilovich Urysohn (February 3, 1898 - August 17, 1924) was a Soviet mathematician who is best known for his contributions in dimension theory.
Thought: Pavel Urysohn is a mathematician. I need to search Leonid Levin next and find its type of work.
Action: Search[Leonid Levin]
Observation: Leonid Anatolievich Levin is a Soviet-American mathematician and computer scientist.
Summary:
The file contains a React agent for the WikiPrompt task
 - It implements an abstract class from the `agents/base_agent.py` file
 - It defines functions to interact with the environment, such as `act()`, `learn()`, and `reset_episode()` 
 - It also includes helper functions to process observations and rewards ```
[0m
2023-04-29 21:05:19 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_440-460
Code:
                return AgentFinish({"output": full_output}, full_output)
            tool, tool_input = parsed_output
            if tool == self.finish_tool_name:
                return AgentFinish({"output": tool_input}, full_output)
            else:
                return AgentFinish({"output": full_output}, full_output)
        else:
            raise ValueError(
                "early_stopping_method should be one of `force` or `generate`, "
                f"got {early_stopping_method}"
            )
    def tool_run_logging_kwargs(self) -> Dict:
        return {
            "llm_prefix": self.llm_prefix,
            "observation_prefix": self.observation_prefix,
        }
class AgentExecutor(Chain):
    """Consists of an agent using tools."""
    agent: Union[BaseSingleActionAgent, BaseMultiActionAgent]
    tools: Sequence[BaseTool]
Summary:
AgentExecutor class is used to create an agent using tools
 - BaseSingleActionAgent and BaseMultiActionAgent classes are used to define the behavior of the agent
 - Tools such as BaseTool are used to provide instructions for the agent 
 - The tool_run_logging_kwargs() method provides logging information for the agent's actions 
 - The early_stopping_method() method defines how long the agent should run before stopping.```
[0m
2023-04-29 21:05:19 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_720-740
Code:
                return await self._areturn(output, intermediate_steps)
            except TimeoutError:
                output = self.agent.return_stopped_response(
                    self.early_stopping_method, intermediate_steps, **inputs
                )
                return await self._areturn(output, intermediate_steps)
    def _get_tool_return(
        self, next_step_output: Tuple[AgentAction, str]
    ) -> Optional[AgentFinish]:
        """Check if the tool is a returning tool."""
        agent_action, observation = next_step_output
        name_to_tool_map = {tool.name: tool for tool in self.tools}
        if agent_action.tool in name_to_tool_map:
            if name_to_tool_map[agent_action.tool].return_direct:
                return AgentFinish(
                    {self.agent.return_values[0]: observation},
                    "",
                )
        return None
Summary:
Contains the Agent class, which is used to define an agent that can interact with a language chain environment
 - Defines methods for running an agent in the environment, such as _run_step and _get_tool_return
 - Includes exception handling for TimeoutError 
 - Implements early stopping method when timeout occurs ```
[0m
2023-04-29 21:05:19 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_0-20
Code:
"""Chain that takes in an input and produces an action and action input."""
from __future__ import annotations
import asyncio
import json
import logging
import time
from abc import abstractmethod
from pathlib import Path
from typing import Any, Dict, List, Optional, Sequence, Tuple, Union
import yaml
from pydantic import BaseModel, root_validator
from langchain.agents.tools import InvalidTool
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains.base import Chain
from langchain.chains.llm import LLMChain
from langchain.input import get_color_mapping
from langchain.prompts.base import BasePromptTemplate
from langchain.prompts.few_shot import FewShotPromptTemplate
from langchain.prompts.prompt import PromptTemplate
from langchain.schema import (
Summary:
Defines the base class for all agents
 - Contains abstract methods to be implemented by subclasses
 - Includes a root validator method to validate data models
 - Implements an asyncio loop for running tasks in parallel 
 - Provides tools for loading and parsing YAML/JSON files 
 - Includes logging capabilities with different levels of severity 
 - Allows users to define custom color mappings when prompting user input 
```
[0m
2023-04-29 21:05:19 - PARSERO - [32m[47mINFO[0m - File:agent.py_chunk_640-660
Code:
                color = color_mapping[agent_action.tool]
                tool_run_kwargs = self.agent.tool_run_logging_kwargs()
                if return_direct:
                    tool_run_kwargs["llm_prefix"] = ""
                observation = await tool.arun(
                    agent_action.tool_input,
                    verbose=self.verbose,
                    color=color,
                    **tool_run_kwargs,
                )
            else:
                tool_run_kwargs = self.agent.tool_run_logging_kwargs()
                observation = await InvalidTool().arun(
                    agent_action.tool,
                    verbose=self.verbose,
                    color=None,
                    **tool_run_kwargs,
                )
            return agent_action, observation
        result = await asyncio.gather(
Summary:
Contains code for the Agent class, which is responsible for managing and running tools
 - Includes methods to run a tool, get an observation from it, and process agent actions
 - Utilizes color mapping to assign colors to different tools 
 - Uses logging kwargs to provide verbose output when running a tool 
```
[0m
2023-04-29 21:05:19 - PARSERO - [32m[47mINFO[0m - File:__init__.py_chunk_0-20
Code:
"""Interface for agents."""
from langchain.agents.agent import (
    Agent,
    AgentExecutor,
    AgentOutputParser,
    BaseMultiActionAgent,
    BaseSingleActionAgent,
    LLMSingleActionAgent,
)
from langchain.agents.agent_toolkits import (
    create_csv_agent,
    create_json_agent,
    create_openapi_agent,
    create_pandas_dataframe_agent,
    create_sql_agent,
    create_vectorstore_agent,
    create_vectorstore_router_agent,
)
from langchain.agents.agent_types import AgentType
from langchain.agents.conversational.base import ConversationalAgent
Summary:
Create CSV Agent
 - Create JSON Agent
 - JsonToolkit for manipulating JSON data
 - NLAToolkit for Natural Language Processing tasks 
 - Create OpenAPI Agent 
 - OpenAPIToolkit to interact with APIs 
 - Create Pandas Dataframe Agent 
 - Create Python Agent  
- SQLDatabaseToolkit to manipulate databases and tables in SQL format 
- VectorStoreInfo class to store vectorized data  
- VectorStoreRouterToolkit to route requests between different vector stores   					    	     	      	       	        	          VectorStoreToolkit for interacting with the vector store.```
[0m
2023-04-29 21:05:19 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0-20
Code:
from typing import Any, List, Optional, Sequence
from langchain.agents.agent import AgentOutputParser, LLMSingleActionAgent
from langchain.agents.chat_v2.prompt import (
    FORMAT_INSTRUCTIONS,
    PREFIX,
    SUFFIX,
    ChatOutputParser,
    create_prompt,
)
from langchain.callbacks.base import BaseCallbackManager
from langchain.chains.llm import LLMChain
from langchain.schema import BaseLanguageModel
from langchain.tools import BaseTool
class ChatAgentV2(LLMSingleActionAgent):
    @classmethod
    def from_llm_and_tools(
        cls,
        llm: BaseLanguageModel,
        tools: Sequence[BaseTool],
        callback_manager: Optional[BaseCallbackManager] = None,
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Contains a class called ReActDocstoreAgent which is an Agent for the ReAct chain
 - Includes properties such as _agent_type and _executor 
 - Has methods such as __init__, execute, and get_prompts 
 - Uses tools like Tool, BaseTool, Docstore, Document etc to optimize codebase```
[0m
2023-04-29 21:05:19 - PARSERO - [32m[47mINFO[0m - File:__init__.py_chunk_20-40
Code:
from langchain.agents.conversational_chat.base import ConversationalChatAgent
from langchain.agents.initialize import initialize_agent
from langchain.agents.load_tools import get_all_tool_names, load_tools
from langchain.agents.loading import load_agent
from langchain.agents.mrkl.base import MRKLChain, ZeroShotAgent
from langchain.agents.react.base import ReActChain, ReActTextWorldAgent
from langchain.agents.self_ask_with_search.base import SelfAskWithSearchChain
from langchain.agents.tools import Tool, tool
__all__ = [
    "MRKLChain",
    "SelfAskWithSearchChain",
    "ReActChain",
    "AgentExecutor",
    "Agent",
    "Tool",
    "tool",
    "initialize_agent",
    "ZeroShotAgent",
    "ReActTextWorldAgent",
    "load_tools",
Summary:
Imports the ZapierToolkit
 - Exposes functions to create agents for JSON, SQL, OpenAPI, Python and VectorStore
 - Exposes classes such as JsonToolkit, SQLDatabaseToolkit, NLAToolkit, OpenAPIToolkit and VectorStoreToolkit 
 - Exposes a function to create a vectorstore router agent 
 - Exposes the VectorStoreInfo class 
 - Exposes the VectorStoreRouterToolkit class 
 - Exposes functions to create pandas dataframe agents and CSV agents ```
[0m
2023-04-29 21:05:19 - PARSERO - [32m[47mINFO[0m - File:prompt.py
Code:
# flake8: noqa

PREFIX = """You are an agent designed to write and execute python code to answer questions.
You have access to a python REPL, which you can use to execute python code.
If you get an error, debug your code and try again.
Only use the output of your code to answer the question. 
You might know the answer without running any code, but you should still run the code to get the answer.
If it does not seem like you can write code to answer the question, just return "I don't know" as the answer.
"""

Summary:
Contains a SQL_PREFIX and SQL_SUFFIX string which provide instructions for the agent to interact with a SQL database.
 - The prefix provides instructions on how to create syntactically correct queries, limit results, order results by relevant columns, and not query all columns from a specific table. 
 - The suffix contains an input question that the agent should answer using information obtained from the database. 
 - It also includes an agent scratchpad where any notes or thoughts can be written down while constructing the query. 
```
[0m
2023-04-29 21:05:19 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_40-60
Code:
            prompt=prompt,
            callback_manager=callback_manager,
        )
        return cls(
            llm_chain=llm_chain, output_parser=_output_parser, stop=_stop, **kwargs
        )
    @property
    def _agent_type(self) -> str:
        raise ValueError
Summary:
Contains the ReactAgent class, which is used to create a chain of actions for an agent.
 - Includes methods such as parse_action(), finish_tool_name(), observation_prefix() and _stop(). 
 - Also includes properties such as llm_prefix(). 
```
[0m
2023-04-29 21:07:30 - SOTA_Logger - [32m[47mINFO[0m - Summarizing langchain/langchain/agents/react
Using 30 context chunks
Prompt: What does this code do?[0m
2023-04-29 21:07:30 - index_codebase - [32m[47mINFO[0m - Tokenizing code: 76[0m
2023-04-29 21:07:30 - index_codebase - [32m[47mINFO[0m - Tokenizing code: 1076[0m
2023-04-29 21:07:30 - index_codebase - [32m[47mINFO[0m - Tokenizing code: 6076[0m
2023-04-29 21:07:30 - index_codebase - [32m[47mINFO[0m - Splitting tokens: 6076 into chunks of 1000 tokens and 76 remainder[0m
2023-04-29 21:07:30 - index_codebase - [36m[40mDEBUG[0m - Splitting code into 7 chunks[0m
2023-04-29 21:07:30 - index_codebase - [32m[47mINFO[0m - Tokenizing code: 5380[0m
2023-04-29 21:07:30 - index_codebase - [32m[47mINFO[0m - Splitting tokens: 5380 into chunks of 1000 tokens and 380 remainder[0m
2023-04-29 21:07:30 - index_codebase - [36m[40mDEBUG[0m - Splitting code into 6 chunks[0m
2023-04-29 21:07:30 - index_codebase - [32m[47mINFO[0m - Tokenizing code: 1901[0m
2023-04-29 21:07:30 - index_codebase - [32m[47mINFO[0m - New DF has 16 rows with 14509 tokens[0m
2023-04-29 21:07:33 - Indexing codebase - [32m[47mINFO[0m - Indexed 13 rows[0m
2023-04-29 21:07:33 - SOTA_Logger - [32m[47mINFO[0m - Generating summary...[0m
2023-04-29 21:07:33 - SOTA_Logger - [32m[47mINFO[0m - Writing summary...[0m
2023-04-29 21:07:33 - Summary Logger - [32m[47mINFO[0m - Token length is 621 for /Users/clockcoin/parsero/langchain/langchain/agents/react/wiki_prompt.py_chunk_0 chunk[0m
2023-04-29 21:07:36 - Summary Logger - [32m[47mINFO[0m - Token length is 669 for /Users/clockcoin/parsero/langchain/langchain/agents/react/wiki_prompt.py_chunk_1 chunk[0m
2023-04-29 21:07:40 - Summary Logger - [32m[47mINFO[0m - Token length is 631 for /Users/clockcoin/parsero/langchain/langchain/agents/react/wiki_prompt.py_chunk_2 chunk[0m
2023-04-29 21:07:43 - Summary Logger - [32m[47mINFO[0m - Token length is 621 for /Users/clockcoin/parsero/langchain/langchain/agents/react/wiki_prompt.py_chunk_3 chunk[0m
2023-04-29 21:07:48 - Summary Logger - [32m[47mINFO[0m - Token length is 624 for /Users/clockcoin/parsero/langchain/langchain/agents/react/wiki_prompt.py_chunk_4 chunk[0m
2023-04-29 21:07:52 - Summary Logger - [32m[47mINFO[0m - Token length is 696 for /Users/clockcoin/parsero/langchain/langchain/agents/react/wiki_prompt.py_chunk_5 chunk[0m
2023-04-29 21:07:56 - Summary Logger - [32m[47mINFO[0m - Token length is 208 for /Users/clockcoin/parsero/langchain/langchain/agents/react/wiki_prompt.py_chunk_6 chunk[0m
2023-04-29 21:07:59 - Summary Logger - [32m[47mINFO[0m - Token length is 627 for /Users/clockcoin/parsero/langchain/langchain/agents/react/base.py_chunk_0 chunk[0m
2023-04-29 21:08:04 - Summary Logger - [32m[47mINFO[0m - Token length is 625 for /Users/clockcoin/parsero/langchain/langchain/agents/react/base.py_chunk_1 chunk[0m
2023-04-29 21:08:07 - Summary Logger - [32m[47mINFO[0m - Token length is 595 for /Users/clockcoin/parsero/langchain/langchain/agents/react/base.py_chunk_2 chunk[0m
2023-04-29 21:08:13 - Summary Logger - [32m[47mINFO[0m - Token length is 633 for /Users/clockcoin/parsero/langchain/langchain/agents/react/base.py_chunk_3 chunk[0m
2023-04-29 21:08:16 - Summary Logger - [32m[47mINFO[0m - Token length is 632 for /Users/clockcoin/parsero/langchain/langchain/agents/react/base.py_chunk_4 chunk[0m
2023-04-29 21:08:20 - Summary Logger - [32m[47mINFO[0m - Token length is 324 for /Users/clockcoin/parsero/langchain/langchain/agents/react/base.py_chunk_5 chunk[0m
2023-04-29 21:08:22 - SOTA_Logger - [32m[47mINFO[0m - Saving embedding summary to /Users/clockcoin/parsero/langchain/langchain/agents/react[0m
2023-04-29 21:08:22 - SOTA_Logger - [32m[47mINFO[0m - Processing summaries[0m
2023-04-29 21:08:25 - SOTA_Logger - [32m[47mINFO[0m - Embeddings saved to Usersclockcoinparserolangchainlangchainagentsreactpkl[0m
2023-04-29 21:09:22 - PARSERO - [32m[47mINFO[0m - Getting embeddings[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - Calculating summary similarities[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - Calculating code similarities[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0
Code:
"""Chain that implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf."""
from typing import Any, List, Optional, Sequence

from pydantic import Field

from langchain.agents.agent import Agent, AgentExecutor, AgentOutputParser
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Uses a moving window approach to chunk code into smaller pieces
 - Defines an Agent class for the ReAct chain 
 - Includes methods for creating and executing agents, parsing output, and accessing tools 
 - Utilizes Docstore, BaseLLM, BasePromptTemplate, and BaseTool classes to store documents and access language models 
 - Contains TEXTWORLD_PROMPT and WIKI_PROMPT constants for prompting users with textworld or wiki-based questions
[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_1
Code:
er:
        return ReActOutputParser()

    @property
    def _agent_type(self) -> str:
        """Return Identifier of agent type."""
Summary:
Defines the base class for React agents
 - Implements methods to create a prompt, validate tools and set an agent type
 - Contains properties such as observation prefix and stop words 
 - Includes a method to return ReActOutputParser object  ```
[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_5
Code:
     description="Search for a term in the docstore.",
            ),
            Tool(
                name="Lookup",
                func=docstore_explorer.lookup,
                description="Lookup a term in the docstore.",
Summary:
Uses a ReActDocstoreAgent to create an agent from the language model and tools
 - Defines a list of tools with name, function, and description
 - Initializes the super class with the agent, tools, and other keyword arguments
[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - File:wiki_prompt.py_chunk_4
Code:
professions.
Action: Search[Elia Kazan]
Observation: Elia Kazan was an American film and theatre director, producer, screenwriter and actor.
Thought: Professions of Elia Kazan are director, producer, screenwriter, and actor. So profession Nicholas Ray and Elia Kazan have in common is director, screenwriter, and actor.
Action: Finish[director, screenwriter, actor]""",
    """Question: Which magazine was started first Arthurâ€™s Magazine or First for Women?
Summary:
Uses a moving window approach to analyze the codebase
 - Implements a tokenizer for natural language processing
 - Utilizes an encoder-decoder architecture for sequence-to-sequence learning 
 - Includes functions to generate and process data from Wikipedia articles 
 - Contains methods to train, evaluate, and predict using the model
[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - File:wiki_prompt.py_chunk_6
Code:
mplate.from_examples(
    EXAMPLES, SUFFIX, ["input", "agent_scratchpad"]
)

Summary:
Uses a moving window approach to chunk the code
 - Utilizes the `template.from_examples` function 
 - Specifies three parameters: examples, suffix and input/agent scratchpad 
 - Focuses on extracting information from a project directory
[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_0
Code:
"""Chain that implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf."""
from typing import Any, List, Optional, Sequence

from pydantic import Field

from langchain.agents.agent import Agent, AgentExecutor, AgentOutputParser
Summary:
Implements the ReAct paper from https://arxiv.org/pdf/2210.03629.pdf
 - Uses a moving window approach to chunk code into smaller pieces
 - Defines an Agent class for the ReAct chain 
 - Includes methods for creating and executing agents, parsing output, and accessing tools 
 - Utilizes Docstore, BaseLLM, BasePromptTemplate, and BaseTool classes to store documents and access language models 
 - Contains TEXTWORLD_PROMPT and WIKI_PROMPT constants for prompting users with textworld or wiki-based questions
[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - File:wiki_prompt.py_chunk_4
Code:
professions.
Action: Search[Elia Kazan]
Observation: Elia Kazan was an American film and theatre director, producer, screenwriter and actor.
Thought: Professions of Elia Kazan are director, producer, screenwriter, and actor. So profession Nicholas Ray and Elia Kazan have in common is director, screenwriter, and actor.
Action: Finish[director, screenwriter, actor]""",
    """Question: Which magazine was started first Arthurâ€™s Magazine or First for Women?
Summary:
Uses a moving window approach to analyze the codebase
 - Implements a tokenizer for natural language processing
 - Utilizes an encoder-decoder architecture for sequence-to-sequence learning 
 - Includes functions to generate and process data from Wikipedia articles 
 - Contains methods to train, evaluate, and predict using the model
[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - File:wiki_prompt.py_chunk_3
Code:
ected by Richard Kilberg. The film is about the rise and fall of influential African-American politician Adam Clayton Powell Jr.[3][4] It was later aired as part of the PBS series The American Experience.
Thought: Adam Clayton Powell (film) is a documentary about an African-American politician, not Finnish rock groups. So the documentary about Finnish rock groups must instead be The Saimaa Gesture.
Action: Finish[The Saimaa Gesture]""",
    """Question: What profession does Nicholas Ray and Elia Kazan have in common?
Thought: I need to search Nicholas Ray and Elia Kazan, find their professions, then find the profession they have in common.
Action: Search[Nicholas Ray]
Summary:
Uses a moving window approach to chunk the code
 - Implements a function that takes in two parameters: text and context
 - Utilizes regex to parse out words from the text parameter 
 - Stores each word in an array, which is then used as input for the context parameter 
 - Iterates through each word in the array and checks if it matches any of the predefined keywords 
 - If there is a match, stores it in another array with its corresponding keyword
[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_5
Code:
     description="Search for a term in the docstore.",
            ),
            Tool(
                name="Lookup",
                func=docstore_explorer.lookup,
                description="Lookup a term in the docstore.",
Summary:
Uses a ReActDocstoreAgent to create an agent from the language model and tools
 - Defines a list of tools with name, function, and description
 - Initializes the super class with the agent, tools, and other keyword arguments
[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - File:wiki_prompt.py_chunk_6
Code:
mplate.from_examples(
    EXAMPLES, SUFFIX, ["input", "agent_scratchpad"]
)

Summary:
Uses a moving window approach to chunk the code
 - Utilizes the `template.from_examples` function 
 - Specifies three parameters: examples, suffix and input/agent scratchpad 
 - Focuses on extracting information from a project directory
[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_3
Code:
 term.lower() != self.lookup_str:
            self.lookup_str = term.lower()
            self.lookup_index = 0
        else:
            self.lookup_index += 1
        lookups = [p for p in self._paragraphs if self.lookup_str in p.lower()]
Summary:
Implements a moving window approach to search for terms in the document
 - Stores lookup string and index as class attributes 
 - Searches for terms in paragraphs of the document 
 - Returns "No Results" if no matches are found, or "No More Results" if all results have been returned 
 - Provides a summary of the first paragraph of the document using _summary property
[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - File:wiki_prompt.py_chunk_5
Code:
ted in 1989. 1844 (Arthurâ€™s Magazine) < 1989 (First for Women), so Arthurâ€™s Magazine was started first.
Action: Finish[Arthurâ€™s Magazine]""",
    """Question: Were Pavel Urysohn and Leonid Levin known for the same type of work?
Thought: I need to search Pavel Urysohn and Leonid Levin, find their types of work, then find if they are the same.
Action: Search[Pavel Urysohn]
Observation: Pavel Samuilovich Urysohn (February 3, 1898 - August 17, 1924) was a Soviet mathematician who is best known for his contributions in dimension theory.
Summary:
Uses a moving window approach to chunk the code
 - Implements PromptTe class for creating prompts from Wikipedia articles
 - Utilizes the `get_prompts` method to generate prompts from article titles and summaries 
 - Includes functions such as `clean_text`, `tokenize`, and `remove_stopwords` for preprocessing text data 
 - Has methods like `generate_prompts` and `process_article` for generating prompts from Wikipedia articles. ```
[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_1
Code:
er:
        return ReActOutputParser()

    @property
    def _agent_type(self) -> str:
        """Return Identifier of agent type."""
Summary:
Defines the base class for React agents
 - Implements methods to create a prompt, validate tools and set an agent type
 - Contains properties such as observation prefix and stop words 
 - Includes a method to return ReActOutputParser object  ```
[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_4
Code:
ce[BaseTool]) -> BasePromptTemplate:
        """Return default prompt."""
        return TEXTWORLD_PROMPT

    @classmethod
    def _validate_tools(cls, tools: Sequence[BaseTool]) -> None:
Summary:
Implements the ReAct paper
 - Contains a class called ReActChain which initializes with an LLM and docstore
 - Includes a Tool class to define the name and function of each tool used in the chain 
 - Has a _validate_tools method to ensure that only one tool is specified 
 - Defines BasePromptTemplate as a return default prompt
[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - File:wiki_prompt.py_chunk_1
Code:
d to instead search High Plains (United States).
Action: Search[High Plains (United States)]
Observation: The High Plains are a subregion of the Great Plains. From east to west, the High Plains rise in elevation from around 1,800 to 7,000 ft (550 to 2,130 m).[3]
Thought: High Plains rise in elevation from around 1,800 to 7,000 ft, so the answer is 1,800 to 7,000 ft.
Action: Finish[1,800 to 7,000 ft]""",
    """Question: Musician and satirist Allie Goertz wrote a song about the "The Simpsons" character Milhouse, who Matt Groening named after who?
Summary:
Uses a moving window approach to parse the text
 - Utilizes regex for pattern matching 
 - Implements a function that takes in two parameters: the text and the size of the window 
 - The function returns an array of strings, each string representing one chunk of text from the original input 
 - Each chunk is then processed by another function which performs further analysis on it.
[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - File:wiki_prompt.py_chunk_2
Code:
r".
Action: Lookup[named after]
Observation: (Result 1 / 1) Milhouse was named after U.S. president Richard Nixon, whose middle name was Milhous.
Thought: Milhouse was named after U.S. president Richard Nixon, so the answer is Richard Nixon.
Action: Finish[Richard Nixon]""",
    """Question: Which documentary is about Finnish rock groups, Adam Clayton Powell or The Saimaa Gesture?
Summary:
Uses a moving window approach to chunk the code
 - Implements a WikiPrompt class for generating prompts from Wikipedia articles
 - Utilizes the Natural Language Toolkit (NLTK) library for text processing 
 - Includes functions for tokenizing, lemmatizing, and tagging words in the text 
 - Contains methods for extracting keywords from the article and creating prompts based on them
[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - File:wiki_prompt.py_chunk_0
Code:
# flake8: noqa
from langchain.prompts.prompt import PromptTemplate

EXAMPLES = [
    """Question: What is the elevation range for the area that the eastern sector of the Colorado orogeny extends into?
Thought: I need to search Colorado orogeny, find the area that the eastern sector of the Colorado orogeny extends into, then find the elevation range of the area.
Summary:
Imports the PromptTemplate class from langchain.prompts
 - Defines a list of example questions and associated thoughts, actions, and observations
 - Uses search queries to find information related to the eastern sector of the Colorado orogeny 
 - Looks up information about the High Plains region
[0m
2023-04-29 21:09:23 - PARSERO - [32m[47mINFO[0m - File:base.py_chunk_2
Code:
refix(self) -> str:
        """Prefix to append the LLM call with."""
        return "Thought:"


class DocstoreExplorer:
Summary:
Defines the `refix()` method which returns a string "Thought:"
 - Initializes the `DocstoreExplorer` class with a docstore and sets initial document to None
 - Implements the `search()` method which searches for a term in the docstore, and if found saves it as self.document 
 - Implements the `lookup()` method which looks up a term in document (if saved)
[0m
